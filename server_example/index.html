<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Undergrowth Server</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="mask-icon" href="/assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h2>Server Information</h2>
        </div>
        <div class="info-section">
            <div class="info-item">
                <div class="info-label">Server Uptime:</div>
                <div class="info-value" id="serverUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">MQTT Port:</div>
                <div class="info-value" id="mqttPort">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">HTTP Port:</div>
                <div class="info-value" id="httpPort">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Active Connections:</div>
                <div class="info-value" id="activeConnections">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Total Messages:</div>
                <div class="info-value" id="totalMessages">Loading...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header-row">
            <h2>Connected Nodes</h2>
        </div>
        <div class="info-section" id="connectedNodes">
            <!-- Connected nodes will be dynamically added here -->
        </div>
    </div>
    
    <div class="container">
        <div class="header-row">
            <h2>Node Graph</h2>
        </div>
        
        <!-- Controls -->
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="info-label">Graph Controls:</div>
                <div class="info-value" style="display: flex; flex-wrap: wrap; align-items: center; gap: 1rem;">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label for="nodeSelect" class="control-label" style="margin-bottom: 0;">Node:</label>
                        <select id="nodeSelect" style="width: 180px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;">
                            <!-- Nodes will be populated dynamically -->
                            <option value="">Select a node</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label for="timeRange" class="control-label" style="margin-bottom: 0;">Time Range:</label>
                        <select id="timeRange" style="width: 120px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;">
                            <option value="1">Last Hour</option>
                            <option value="24" selected>Last 24 Hours</option>
                            <option value="168">Last Week</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label for="points" class="control-label" style="margin-bottom: 0;">Points:</label>
                        <select id="points" style="width: 120px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;">
                            <option value="100" selected>100 points</option>
                            <option value="1000">1000 points</option>
                            <option value="10000">10000 points</option>
                        </select>
                    </div>
                    <button id="updateGraphButton" style="margin-left: auto; background: var(--success-color); color: var(--text-primary); border: none; padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer;">
                        Update
                    </button>
                </div>
            </div>
        </div>
        
        <h3>Temperature (°F)</h3>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="chart-canvas" style="height: 300px;">
                    <canvas id="tempChart"></canvas>
                </div>
            </div>
        </div>

        <h3>Humidity (%)</h3>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="chart-canvas" style="height: 300px;">
                    <canvas id="humidityChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header-row">
            <h2>Data Synchronization</h2>
        </div>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="info-label">Sync Interval:</div>
                <div class="info-value" style="display: flex; align-items: center; gap: 1rem;">
                    <input type="number" id="syncInterval" min="5" style="width: 100px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;" /> 
                    <span>seconds</span>
                    <button id="updateSyncInterval" style="background: var(--success-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer;">Update</button>
                </div>
            </div>
        </div>
        
        <h3>Node Data Collection Status</h3>
        <div class="info-section" id="nodeSyncStatus">
            <!-- Node sync status will be dynamically added here -->
        </div>
    </div>

    <script>
        // Chart variables
        let tempChart = null;
        let humidityChart = null;
        
        // Update server information
        function updateServerInfo() {
            fetch('/api/mqtt-stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('serverUptime').textContent = formatUptime(data.start_time);
                    document.getElementById('mqttPort').textContent = data.mqtt_port || '1883';
                    document.getElementById('httpPort').textContent = data.http_port || '3000';
                    document.getElementById('activeConnections').textContent = data.active_connections || '0';
                    document.getElementById('totalMessages').textContent = data.total_messages || '0';
                })
                .catch(error => console.error('Error fetching server info:', error));
        }

        // Update connected nodes
        function updateConnectedNodes() {
            fetch('/api/connected-nodes')
                .then(response => response.json())
                .then(nodes => {
                    const container = document.getElementById('connectedNodes');
                    container.innerHTML = '';
                    
                    // Also update the node select dropdown for graphs
                    const nodeSelect = document.getElementById('nodeSelect');
                    const currentValue = nodeSelect.value; // Save current selection
                    
                    // Clear dropdown except for first option
                    while (nodeSelect.options.length > 1) {
                        nodeSelect.remove(1);
                    }
                    
                    nodes.forEach(node => {
                        // Add to connected nodes section
                        const nodeElement = document.createElement('div');
                        nodeElement.className = 'info-item';
                        nodeElement.innerHTML = `
                            <div class="info-label">${node.hostname || node.id}</div>
                            <div class="info-value">
                                <div>IP: ${node.ip_address || 'Unknown'}</div>
                                <div>Connected: ${formatTimeAgo(node.connected_since)}</div>
                                <div>Last Message: ${formatTimeAgo(node.last_message)}</div>
                                <div>Messages: ${node.messages_received || 0}</div>
                            </div>
                        `;
                        container.appendChild(nodeElement);
                        
                        // Add to dropdown
                        const option = document.createElement('option');
                        option.value = node.id;
                        option.textContent = node.hostname || node.id;
                        nodeSelect.appendChild(option);
                    });
                    
                    // Restore previous selection if it exists
                    if (currentValue) {
                        nodeSelect.value = currentValue;
                    }
                })
                .catch(error => console.error('Error fetching connected nodes:', error));
        }
        
        // Update sync status
        function updateSyncStatus() {
            fetch('/api/sync-status')
                .then(response => response.json())
                .then(data => {
                    // Update sync interval input
                    document.getElementById('syncInterval').value = Math.floor(data.syncInterval / 1000);
                    
                    // Update node sync status
                    const nodeContainer = document.getElementById('nodeSyncStatus');
                    nodeContainer.innerHTML = '';
                    
                    data.nodes.forEach(node => {
                        // Fetch sequence information for this node
                        fetch(`/api/node-sequence-info/${node.node_id}`)
                            .then(response => response.json())
                            .then(seqInfo => {
                                const nodeElement = document.createElement('div');
                                nodeElement.className = 'info-item';
                                
                                // Calculate sequence gap
                                const sequenceGap = seqInfo.max_sequence - seqInfo.last_sequence;
                                const sequenceStatus = sequenceGap > 0 ? 
                                    `<span style="color: var(--active-color)">Behind by ${sequenceGap} sequences</span>` : 
                                    `<span style="color: var(--success-color)">Up to date</span>`;
                                
                                nodeElement.innerHTML = `
                                    <div class="info-label">${node.name || node.node_id}</div>
                                    <div class="info-value">
                                        <div>Records on Node: ${seqInfo.total_records || 0}</div>
                                        <div>Records Synced: ${seqInfo.last_sequence || 0}</div>
                                        <div>Last Sync: ${node.last_sync_timestamp ? formatTimeAgo(node.last_sync_timestamp) : 'Never'}</div>
                                        <div>Sync Status: ${sequenceStatus}</div>
                                        <div style="margin-top: 0.5rem;">
                                            <button
                                                class="sync-button"
                                                data-node-id="${node.node_id}" 
                                                style="background: var(--active-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer;"
                                            >
                                                Force Sync
                                            </button>
                                        </div>
                                    </div>
                                `;
                                nodeContainer.appendChild(nodeElement);
                                
                                // Add event listener to sync button
                                const syncButton = nodeElement.querySelector('.sync-button');
                                syncButton.addEventListener('click', function() {
                                    const nodeId = this.getAttribute('data-node-id');
                                    requestSequenceBasedSync(nodeId, seqInfo.last_sequence);
                                });
                            })
                            .catch(error => {
                                console.error(`Error fetching sequence info for node ${node.node_id}:`, error);
                                
                                // Fallback display without sequence info
                                const nodeElement = document.createElement('div');
                                nodeElement.className = 'info-item';
                                nodeElement.innerHTML = `
                                    <div class="info-label">${node.name || node.node_id}</div>
                                    <div class="info-value">
                                        <div>Last Seen: ${formatTimeAgo(node.last_seen_timestamp)}</div>
                                        <div>Last Sync: ${node.last_sync_timestamp ? formatTimeAgo(node.last_sync_timestamp) : 'Never'}</div>
                                        <div>Sequence Info: Unable to retrieve</div>
                                        <div style="margin-top: 0.5rem;">
                                            <button
                                                class="sync-button"
                                                data-node-id="${node.node_id}" 
                                                style="background: var(--active-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer;"
                                            >
                                                Force Sync
                                            </button>
                                        </div>
                                    </div>
                                `;
                                nodeContainer.appendChild(nodeElement);
                                
                                // Add event listener to sync button
                                const syncButton = nodeElement.querySelector('.sync-button');
                                syncButton.addEventListener('click', function() {
                                    const nodeId = this.getAttribute('data-node-id');
                                    requestSequenceBasedSync(nodeId);
                                });
                            });
                    });
                })
                .catch(error => console.error('Error fetching sync status:', error));
        }
        
        // Request sequence-based sync from a node
        function requestSequenceBasedSync(nodeId, lastSequence = 0) {
            const startSequence = lastSequence + 1;
            
            fetch('/api/request-history', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    nodeId: nodeId,
                    startSequence: startSequence,
                    endSequence: null  // Request up to the latest data
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`Sequence-based sync request submitted. Request ID: ${data.requestId}`);
                    // Update sync status after a short delay
                    setTimeout(updateSyncStatus, 2000);
                } else {
                    alert(`Error: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error requesting sequence-based sync:', error);
                alert('Error requesting sequence-based sync. Check console for details.');
            });
        }

        // Modify the existing requestHistoricalData function to prefer sequence-based sync if available
        function requestHistoricalData(nodeId, startTime = null, endTime = null) {
            // Try to get sequence info first
            fetch(`/api/node-sequence-info/${nodeId}`)
                .then(response => response.json())
                .then(seqInfo => {
                    // If we have sequence info, use sequence-based sync
                    if (seqInfo && seqInfo.last_sequence !== undefined) {
                        requestSequenceBasedSync(nodeId, seqInfo.last_sequence);
                    } else {
                        // Fall back to time-based sync
                        if (!startTime) startTime = '2000-01-01T00:00:00Z';
                        if (!endTime) endTime = new Date().toISOString();
                        
                        fetch('/api/request-history', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                nodeId: nodeId,
                                startTime: startTime,
                                endTime: endTime
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                alert(`Time-based request submitted. Request ID: ${data.requestId}`);
                                // Update sync status after a short delay
                                setTimeout(updateSyncStatus, 2000);
                            } else {
                                alert(`Error: ${data.error}`);
                            }
                        })
                        .catch(error => {
                            console.error('Error requesting historical data:', error);
                            alert('Error requesting historical data. Check console for details.');
                        });
                    }
                })
                .catch(error => {
                    console.error('Error fetching sequence info:', error);
                    
                    // Fall back to time-based sync on error
                    if (!startTime) startTime = '2000-01-01T00:00:00Z';
                    if (!endTime) endTime = new Date().toISOString();
                    
                    fetch('/api/request-history', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            nodeId: nodeId,
                            startTime: startTime,
                            endTime: endTime
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert(`Time-based request submitted. Request ID: ${data.requestId}`);
                            setTimeout(updateSyncStatus, 2000);
                        } else {
                            alert(`Error: ${data.error}`);
                        }
                    })
                    .catch(error => {
                        console.error('Error requesting historical data:', error);
                        alert('Error requesting historical data. Check console for details.');
                    });
                });
        }
        
        // Update sync interval
        function updateInterval() {
            const intervalSeconds = document.getElementById('syncInterval').value;
            const intervalMs = intervalSeconds * 1000;
            
            if (intervalSeconds < 5) {
                alert('Sync interval must be at least 5 seconds');
                return;
            }
            
            fetch('/api/sync-interval', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    interval: intervalMs
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`Sync interval updated to ${intervalSeconds} seconds`);
                    updateSyncStatus();
                } else {
                    alert(`Error: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error updating sync interval:', error);
                alert('Error updating sync interval. Check console for details.');
            });
        }

        // Helper function to format uptime
        function formatUptime(startTime) {
            const start = new Date(startTime);
            const now = new Date();
            const diff = now - start;
            
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            
            return `${days}d ${hours}h ${minutes}m`;
        }

        // Helper function to format time ago
        function formatTimeAgo(timestamp) {
            if (!timestamp) return 'Never';
            const date = new Date(timestamp);
            const now = new Date();
            const diff = now - date;
            
            const minutes = Math.floor(diff / (1000 * 60));
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }
        
        // Helper function to format date
        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp);
            
            // Return ISO date without milliseconds
            return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
        }
        
        // Graph functions
        function fetchAndUpdateChart(nodeId, type) {
            if (!nodeId) return;
            
            const timeRange = document.getElementById('timeRange').value;
            const points = document.getElementById('points').value;
            const now = new Date();
            const startDate = new Date(now.getTime() - (timeRange * 3600 * 1000)).toISOString();
            
            // Build URL for the chart data using the binned endpoint
            const url = new URL('/api/sensor-data/binned', window.location.origin);
            url.searchParams.set('node_id', nodeId);
            url.searchParams.set('reading_type', type);
            url.searchParams.set('start_time', startDate);
            url.searchParams.set('bin_count', points);
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    // Destroy existing chart if it exists
                    if (type === 'temperature' && tempChart) {
                        tempChart.destroy();
                    } else if (type === 'humidity' && humidityChart) {
                        humidityChart.destroy();
                    }
                    
                    // No data
                    if (!data || data.length === 0) {
                        document.getElementById(type === 'temperature' ? 'tempChart' : 'humidityChart')
                            .parentElement.innerHTML = `<div class="no-data" style="display:flex; justify-content:center; align-items:center; height:300px; color:var(--text-secondary);">No ${type} data available for selected period</div>`;
                        return;
                    }
                    
                    // Create new chart
                    const ctx = document.getElementById(type === 'temperature' ? 'tempChart' : 'humidityChart').getContext('2d');
                    const chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.map(row => new Date(row.timestamp).toLocaleString()),
                            datasets: [{
                                label: type === 'temperature' ? 'Temperature (°F)' : 'Humidity (%)',
                                data: data.map(row => row.value),
                                borderColor: type === 'temperature' ? 'rgb(255, 99, 132)' : 'rgb(54, 162, 235)',
                                backgroundColor: type === 'temperature' ? 'rgba(255, 99, 132, 0.1)' : 'rgba(54, 162, 235, 0.1)',
                                tension: 0.1,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    labels: {
                                        color: '#e8e6e3'
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: '#e8e6e3'
                                    }
                                },
                                y: {
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: '#e8e6e3'
                                    },
                                    title: {
                                        display: true,
                                        text: type === 'temperature' ? 'Temperature (°F)' : 'Humidity (%)',
                                        color: '#e8e6e3'
                                    }
                                }
                            }
                        }
                    });
                    
                    // Store reference to the new chart
                    if (type === 'temperature') {
                        tempChart = chart;
                    } else {
                        humidityChart = chart;
                    }
                })
                .catch(error => console.error(`Error fetching ${type} data:`, error));
        }
        
        // Bin data into the requested number of points (client-side binning not needed with binned API)
        function binData(data, binCount) {
            // Server does the binning now
            return data;
        }
        
        // Update charts
        function updateCharts() {
            const nodeId = document.getElementById('nodeSelect').value;
            
            if (!nodeId) {
                alert('Please select a node to display data');
                return;
            }
            
            fetchAndUpdateChart(nodeId, 'temperature');
            fetchAndUpdateChart(nodeId, 'humidity');
        }

        // Update information periodically
        setInterval(updateServerInfo, 10000);
        setInterval(updateConnectedNodes, 10000);
        setInterval(updateSyncStatus, 10000);
        
        // Add event listeners
        document.getElementById('updateSyncInterval').addEventListener('click', updateInterval);
        document.getElementById('updateGraphButton').addEventListener('click', updateCharts);
        
        // Initial update
        updateServerInfo();
        updateConnectedNodes();
        updateSyncStatus();
    </script>
</body>
</html> 