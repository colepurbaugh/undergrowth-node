<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Undergrowth Server</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="mask-icon" href="/assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* Fix background image issues */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/backgrounds/undergrowth_logo.png');
            background-repeat: no-repeat;
            background-position: top center;
            background-size: 90vh auto;
            z-index: -1;
            pointer-events: none;
        }
        
        body {
            background-image: none !important; /* Remove original background */
        }
        
        /* Prevent layout shifts */
        .info-section {
            min-height: 100px; /* Preserve minimum height */
            position: relative; /* For absolute positioning of children */
        }
        
        #connectedNodes .info-item {
            min-height: 260px; /* Ensure consistent height for node boxes */
        }
        
        .node-stats {
            min-height: 140px; /* Reserve space for stats */
        }
        
        /* Prevent container height changes */
        .container {
            position: relative;
            min-height: 250px; /* Adjust based on content */
        }
        
        /* Prevent text size/position changes during updates */
        .info-value {
            height: auto !important;
            min-height: 1.6em;
        }
        
        /* Prevent button size changes */
        button {
            height: 32px !important;
            line-height: 1 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h2>Server Information</h2>
        </div>
        <div class="info-section">
            <div class="info-item">
                <div class="info-label">Server Uptime:</div>
                <div class="info-value" id="serverUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">MQTT Port:</div>
                <div class="info-value" id="mqttPort">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">HTTP Port:</div>
                <div class="info-value" id="httpPort">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Active Connections:</div>
                <div class="info-value" id="activeConnections">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Total Messages:</div>
                <div class="info-value" id="totalMessages">Loading...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header-row">
            <h2>Connected Nodes</h2>
        </div>
        <div class="info-section" id="connectedNodes">
            <!-- Connected nodes will be dynamically added here -->
        </div>
    </div>
    
    <div class="container">
        <div class="header-row">
            <h2>Node Graph</h2>
        </div>
        
        <!-- Controls -->
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="info-label">Graph Controls:</div>
                <div class="info-value" style="display: flex; flex-wrap: wrap; align-items: center; gap: 1rem;">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label for="nodeSelect" class="control-label" style="margin-bottom: 0;">Node:</label>
                        <select id="nodeSelect" style="width: 180px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;">
                            <!-- Nodes will be populated dynamically -->
                            <option value="">Select a node</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label for="timeRange" class="control-label" style="margin-bottom: 0;">Time Range:</label>
                        <select id="timeRange" style="width: 120px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;">
                            <option value="1">Last Hour</option>
                            <option value="24" selected>Last 24 Hours</option>
                            <option value="168">Last Week</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label for="points" class="control-label" style="margin-bottom: 0;">Points:</label>
                        <select id="points" style="width: 120px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;">
                            <option value="100" selected>100 points</option>
                            <option value="1000">1000 points</option>
                            <option value="10000">10000 points</option>
                        </select>
                    </div>
                    <button id="updateGraphButton" style="margin-left: auto; background: var(--success-color); color: var(--text-primary); border: none; padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer;">
                        Update
                    </button>
                </div>
            </div>
        </div>
        
        <h3>Temperature (째F)</h3>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="chart-canvas" style="height: 300px;">
                    <canvas id="tempChart"></canvas>
                </div>
            </div>
        </div>

        <h3>Humidity (%)</h3>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="chart-canvas" style="height: 300px;">
                    <canvas id="humidityChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header-row">
            <h2>Data Synchronization</h2>
            <button id="resetPendingButton" style="background: var(--emergency-color); color: var(--text-primary); border: none; padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer;">
                Reset Pending Requests
            </button>
        </div>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1;">
                <div class="info-label">Sync Status:</div>
                <div class="info-value" id="syncStatus">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Sync Interval:</div>
                <div class="info-value" style="display: flex; align-items: center; gap: 1rem;">
                    <input type="number" id="syncInterval" min="5" style="width: 100px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;" /> 
                    <span>seconds</span>
                    <button id="updateSyncInterval" style="background: var(--success-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer;">Update</button>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Batch Size:</div>
                <div class="info-value" style="display: flex; align-items: center; gap: 1rem;">
                    <input type="number" id="batchSize" min="10" max="10000" style="width: 100px; background: #444; color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.25rem; border-radius: 4px;" /> 
                    <span>records</span>
                    <button id="updateBatchSize" style="background: var(--success-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer;">Update</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header-row">
            <h2>Server Logs</h2>
            <button id="clearLogsButton" style="background: var(--error-color); color: var(--text-primary); border: none; padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer;">
                Clear Logs
            </button>
        </div>
        <div class="info-section">
            <div class="info-item" style="grid-column: 1 / -1; min-height: 200px;">
                <div id="logWindow" style="width: 100%; height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.9rem; white-space: pre-wrap; color: var(--text-primary); background-color: #222; padding: 0.5rem; border-radius: 4px;">
                    <!-- Logs will be displayed here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Chart variables
        let tempChart = null;
        let humidityChart = null;
        
        // Helper function to only update text content when it changes
        function updateTextIfChanged(element, newText) {
            if (!element) return false;
            if (element.textContent !== newText) {
                element.textContent = newText;
                return true;
            }
            return false;
        }
        
        // Helper function to update an attribute only if it changed
        function updateAttrIfChanged(element, attr, value) {
            if (!element) return false;
            if (element.getAttribute(attr) !== value) {
                element.setAttribute(attr, value);
                return true;
            }
            return false;
        }
        
        // Update server information with minimal DOM changes
        function updateServerInfo() {
            fetch('/api/mqtt-stats')
                .then(response => response.json())
                .then(data => {
                    const elements = {
                        uptime: document.getElementById('serverUptime'),
                        mqttPort: document.getElementById('mqttPort'),
                        httpPort: document.getElementById('httpPort'),
                        connections: document.getElementById('activeConnections'),
                        messages: document.getElementById('totalMessages')
                    };
                    
                    updateTextIfChanged(elements.uptime, formatUptime(data.start_time));
                    updateTextIfChanged(elements.mqttPort, data.mqtt_port || '1883');
                    updateTextIfChanged(elements.httpPort, data.http_port || '3000');
                    updateTextIfChanged(elements.connections, data.active_connections || '0');
                    updateTextIfChanged(elements.messages, data.total_messages || '0');
                })
                .catch(error => console.error('Error fetching server info:', error));
        }

        // Function to handle node stats API errors
        function getEmptyNodeStats() {
            return {
                first_timestamp: null,
                last_timestamp: null,
                total_records: 0,
                last_sequence: 0,
                max_sequence: 0
            };
        }

        // Update connected nodes with optimized DOM updates
        function updateConnectedNodes() {
            // Get connected nodes first
            fetch('/api/connected-nodes')
                .then(response => response.json())
                .then(nodes => {
                    const container = document.getElementById('connectedNodes');
                    
                    // Create a document fragment to batch DOM updates
                    const fragment = document.createDocumentFragment();
                    
                    // Also update the node select dropdown for graphs
                    const nodeSelect = document.getElementById('nodeSelect');
                    const currentValue = nodeSelect.value; // Save current selection
                    
                    // Create a new dropdown content
                    const dropdownFragment = document.createDocumentFragment();
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = "Select a node";
                    dropdownFragment.appendChild(defaultOption);
                    
                    if (nodes.length === 0) {
                        const emptyItem = document.createElement('div');
                        emptyItem.className = 'info-item';
                        emptyItem.innerHTML = '<div class="info-value">No nodes currently connected</div>';
                        fragment.appendChild(emptyItem);
                    } else {
                        // Create a promise for each node to fetch its detailed stats
                        const nodePromises = nodes.map(node => {
                            return fetch(`/api/node-stats/${node.id}`)
                                .then(response => {
                                    if (!response.ok) {
                                        console.error(`Error fetching stats for node ${node.id}: ${response.status}`);
                                        return { node, stats: getEmptyNodeStats() };
                                    }
                                    return response.json()
                                        .then(stats => ({ node, stats }))
                                        .catch(error => {
                                            console.error(`Error parsing JSON for node ${node.id}:`, error);
                                            return { node, stats: getEmptyNodeStats() };
                                        });
                                })
                                .catch(error => {
                                    console.error(`Network error fetching stats for node ${node.id}:`, error);
                                    return { node, stats: getEmptyNodeStats() };
                                });
                        });
                        
                        // Process all nodes once we have their stats
                        Promise.all(nodePromises).then(nodeData => {
                            // Create a document fragment to build all nodes
                            const fragment = document.createDocumentFragment();
                            const dropdownFragment = document.createDocumentFragment();
                            
                            // Get current value to restore selection
                            const currentValue = nodeSelect.value;
                            
                            // Process each node
                            nodeData.forEach(({ node, stats }) => {
                                // Add to dropdown
                                const option = document.createElement('option');
                                option.value = node.id;
                                option.textContent = node.hostname || node.id;
                                dropdownFragment.appendChild(option);
                                
                                // Create node element
                                const nodeElement = document.createElement('div');
                                nodeElement.className = 'info-item';
                                
                                // Calculate values behind
                                const serverValues = stats?.total_records || 0;
                                const nodeValues = stats?.max_sequence || 0;
                                const valuesBehind = nodeValues - serverValues;
                                
                                // Determine sync status message based on values
                                let syncStatusMessage = '';
                                let syncStatusClass = '';
                                
                                if (nodeValues === 0 && serverValues === 0) {
                                    syncStatusMessage = 'No data collected yet';
                                    syncStatusClass = 'text-warning';
                                } else if (nodeValues <= serverValues) {
                                    // This shouldn't happen as node should always have at least as many values as server
                                    syncStatusMessage = 'Data inconsistency detected';
                                    syncStatusClass = 'text-warning';
                                } else if (valuesBehind > 0) {
                                    syncStatusMessage = `Server needs to sync ${valuesBehind.toLocaleString()} values`;
                                    syncStatusClass = 'text-warning';
                                } else {
                                    syncStatusMessage = 'All available data synced';
                                    syncStatusClass = 'text-success';
                                }
                                
                                // Format last message time as actual timestamp instead of relative time
                                const lastMessageTime = formatDateTime(node.last_message);
                                
                                // Display sensor list without values, just which sensors are present
                                let sensorInfoHtml = '';
                                if (node.data && node.data.sensorStats && node.data.sensorStats.length > 0) {
                                    sensorInfoHtml = `
                                        <div style="margin-top: 0.75rem; border-top: 1px dashed var(--border-color); padding-top: 0.5rem;">
                                            <div style="font-weight: bold; margin-bottom: 0.25rem;">Detected Sensors:</div>
                                            <table style="width: 100%; font-family: monospace; font-size: 0.85rem; margin-bottom: 0.5rem;">
                                                <thead>
                                                    <tr>
                                                        <th style="text-align: left; padding-right: 0.5rem;">Sensor</th>
                                                        <th style="text-align: right; padding-right: 0.5rem;">Temp Records</th>
                                                        <th style="text-align: right; padding-right: 0.5rem;">Humidity Records</th>
                                                        <th style="text-align: right;">Total Records</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                            `;
                                            
                                            // Add rows for each sensor
                                            node.data.sensorStats.forEach(sensor => {
                                                const sensorName = sensor.name.split(' ')[0]; // Get just the sensor type
                                                const sensorAddress = sensor.address.split('-')[0]; // Get just the address
                                                
                                                sensorInfoHtml += `
                                                    <tr>
                                                        <td style="text-align: left; padding-right: 0.5rem;">${sensorName} ${sensorAddress}</td>
                                                        <td style="text-align: right; padding-right: 0.5rem;">${sensor.temperatureCount.toLocaleString()}</td>
                                                        <td style="text-align: right; padding-right: 0.5rem;">${sensor.humidityCount.toLocaleString()}</td>
                                                        <td style="text-align: right;">${sensor.totalCount.toLocaleString()}</td>
                                                    </tr>
                                                `;
                                            });
                                            
                                            // Add total row
                                            sensorInfoHtml += `
                                                        </tbody>
                                                        <tfoot>
                                                            <tr style="border-top: 1px solid var(--border-color);">
                                                                <td style="text-align: left; padding-right: 0.5rem; font-weight: bold;">TOTAL</td>
                                                                <td style="text-align: right; padding-right: 0.5rem; font-weight: bold;">${node.data.sensorStats.reduce((sum, s) => sum + s.temperatureCount, 0).toLocaleString()}</td>
                                                                <td style="text-align: right; padding-right: 0.5rem; font-weight: bold;">${node.data.sensorStats.reduce((sum, s) => sum + s.humidityCount, 0).toLocaleString()}</td>
                                                                <td style="text-align: right; font-weight: bold;">${node.data.totalRecords ? node.data.totalRecords.toLocaleString() : '0'}</td>
                                                            </tr>
                                                        </tfoot>
                                                    </table>
                                                </div>
                                            `;
                                        }
                                        
                                        // Update the node element HTML
                                        nodeElement.innerHTML = `
                                            <div class="info-label">${node.hostname || node.id}</div>
                                            <div class="info-value">
                                                <div>IP: ${node.ip_address || 'Unknown'}</div>
                                                <div>Last Message: ${lastMessageTime}</div>
                                                <div>First Server DB Value: ${formatDateTime(stats.first_timestamp)}</div>
                                                <div>Latest Server DB Value: ${formatDateTime(stats.last_timestamp)}</div>
                                                <div>Server Database Values: ${serverValues.toLocaleString()}</div>
                                                <div>Node Database Values: ${nodeValues.toLocaleString()}</div>
                                                <div class="${syncStatusClass}">
                                                    ${syncStatusMessage}
                                                </div>
                                                ${sensorInfoHtml}
                                                <div style="margin-top: 0.5rem;">
                                                    <button 
                                                        class="view-data-button"
                                                        data-node-id="${node.id}"
                                                        style="background: var(--active-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; margin-right: 0.5rem;"
                                                    >
                                                        View Data
                                                    </button>
                                                    <button 
                                                        class="force-sync-button"
                                                        data-node-id="${node.id}"
                                                        style="background: var(--success-color); color: var(--text-primary); border: none; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer;"
                                                    >
                                                        Force Sync
                                                    </button>
                                                </div>
                                            </div>
                                        `;
                                        
                                        fragment.appendChild(nodeElement);
                            });
                            
                            // Single DOM update for the container
                            container.innerHTML = '';
                            container.appendChild(fragment);
                            
                            // Single DOM update for the dropdown
                            nodeSelect.innerHTML = '';
                            nodeSelect.appendChild(dropdownFragment);
                            
                            // Restore previous selection if it exists
                            if (currentValue) {
                                nodeSelect.value = currentValue;
                            }
                            
                            // Add event listeners after DOM is updated
                            nodeData.forEach(({ node }) => {
                                const viewButton = document.querySelector(`.view-data-button[data-node-id="${node.id}"]`);
                                if (viewButton) {
                                    viewButton.addEventListener('click', function() {
                                        document.getElementById('nodeSelect').value = node.id;
                                        updateCharts();
                                    });
                                }
                                
                                const syncButton = document.querySelector(`.force-sync-button[data-node-id="${node.id}"]`);
                                if (syncButton) {
                                    syncButton.addEventListener('click', function() {
                                        requestSequenceBasedSync(node.id);
                                    });
                                }
                            });
                        });
                    }
                })
                .catch(error => console.error('Error fetching connected nodes:', error));
        }
        
        // Format time ago (e.g., '5 minutes ago')
        function formatTimeAgo(timestamp) {
            if (!timestamp) return 'Never';
            
            try {
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) return 'Invalid date';
                
                const now = new Date();
                const seconds = Math.floor((now - date) / 1000);
                
                if (seconds < 5) return 'Just now';
                if (seconds < 60) return `${seconds} seconds ago`;
                
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                
                const days = Math.floor(hours / 24);
                return `${days}d ago`;
            } catch (error) {
                console.error('Error formatting time ago:', error);
                return 'Unknown';
            }
        }
        
        // Safely format date or return 'None'
        function formatDateTime(dateStr) {
            if (!dateStr) return 'None';
            
            try {
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return 'Invalid date';
                
                return `${date.toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: '2-digit'})} ${date.toLocaleTimeString('en-US', {hour: '2-digit', minute:'2-digit', second:'2-digit'})}`;
            } catch (error) {
                console.error('Error formatting date time:', error);
                return 'None';
            }
        }
        
        // Utility function to get pending request count
        function getPendingRequestCount(historyRequests) {
            if (!historyRequests || !Array.isArray(historyRequests)) {
                return 0;
            }
            return historyRequests.filter(req => req.status === 'pending').length;
        }
        
        // Utility function to get the last request time
        function getLastRequestTime(historyRequests) {
            if (!historyRequests || !Array.isArray(historyRequests) || historyRequests.length === 0) {
                return 'Never';
            }
            
            // Sort by timestamp descending
            const sortedRequests = [...historyRequests].sort((a, b) => {
                return new Date(b.created_at) - new Date(a.created_at);
            });
            
            // Return formatted time ago
            return formatTimeAgo(sortedRequests[0].created_at);
        }
        
        // Update sync status
        function updateSyncStatus() {
            fetch('/api/sync-status')
                .then(response => response.json())
                .then(data => {
                    // Update sync interval input
                    const syncIntervalInput = document.getElementById('syncInterval');
                    if (syncIntervalInput) {
                        syncIntervalInput.value = Math.floor(data.syncInterval / 1000);
                    }
                    
                    // Update global sync status only, node-specific info is now in the Connected Nodes section
                    const syncStatusContainer = document.getElementById('syncStatus');
                    if (syncStatusContainer) {
                        // Show sync interval and global stats
                        syncStatusContainer.innerHTML = `
                            <div>Sync Interval: ${Math.floor(data.syncInterval / 1000)} seconds</div>
                            <div>Pending Requests: ${getPendingRequestCount(data.historyRequests)}</div>
                            <div>Last Request: ${getLastRequestTime(data.historyRequests)}</div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error fetching sync status:', error);
                    // Update sync status with error message
                    const syncStatusContainer = document.getElementById('syncStatus');
                    if (syncStatusContainer) {
                        syncStatusContainer.innerHTML = 'Error fetching sync status';
                    }
                });
        }
        
        // Request sequence-based sync from node
        function requestSequenceBasedSync(nodeId) {
            // Get the latest sync information from the server
            fetch(`/api/node-stats/${nodeId}`)
                .then(response => response.json())
                .then(stats => {
                    const lastSequence = stats.last_sequence || 0;
                    
                    // Make the sync request using the last sequence
                    fetch('/api/request-history', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            nodeId: nodeId,
                            startSequence: lastSequence + 1,
                            endSequence: null  // Request up to the latest data
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            addLogEntry(`Initiated sync for node ${nodeId} from sequence ${lastSequence + 1}`, 'success');
                            // Update displays after a short delay
                            setTimeout(() => {
                                updateSyncStatus();
                                updateConnectedNodes();
                            }, 2000);
                        } else {
                            addLogEntry(`Failed to initiate sync: ${data.error}`, 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error initiating sync:', error);
                        addLogEntry(`Error initiating sync: ${error.message}`, 'error');
                    });
                })
                .catch(error => {
                    console.error(`Error fetching node stats for ${nodeId}:`, error);
                    addLogEntry(`Error fetching node stats: ${error.message}`, 'error');
                    
                    // Fallback to syncing without a sequence
                    fetch('/api/request-history', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            nodeId: nodeId,
                            startSequence: 1,
                            endSequence: null
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            addLogEntry(`Initiated sync for node ${nodeId} (full sync)`, 'success');
                            // Update displays after a short delay
                            setTimeout(() => {
                                updateSyncStatus();
                                updateConnectedNodes();
                            }, 2000);
                        } else {
                            addLogEntry(`Failed to initiate sync: ${data.error}`, 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error initiating sync:', error);
                        addLogEntry(`Error initiating sync: ${error.message}`, 'error');
                    });
                });
        }

        // Modify the existing requestHistoricalData function to prefer sequence-based sync if available
        function requestHistoricalData(nodeId, startTime = null, endTime = null) {
            // Try to get sequence info first
            fetch(`/api/node-sequence-info/${nodeId}`)
                .then(response => response.json())
                .then(seqInfo => {
                    // If we have sequence info, use sequence-based sync
                    if (seqInfo && seqInfo.last_sequence !== undefined) {
                        requestSequenceBasedSync(nodeId, seqInfo.last_sequence);
                    } else {
                        // Fall back to time-based sync
                        if (!startTime) startTime = '2000-01-01T00:00:00Z';
                        if (!endTime) endTime = new Date().toISOString();
                        
                        fetch('/api/request-history', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                nodeId: nodeId,
                                startTime: startTime,
                                endTime: endTime
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                alert(`Time-based request submitted. Request ID: ${data.requestId}`);
                                // Update sync status after a short delay
                                setTimeout(updateSyncStatus, 2000);
                            } else {
                                alert(`Error: ${data.error}`);
                            }
                        })
                        .catch(error => {
                            console.error('Error requesting historical data:', error);
                            alert('Error requesting historical data. Check console for details.');
                        });
                    }
                })
                .catch(error => {
                    console.error('Error fetching sequence info:', error);
                    
                    // Fall back to time-based sync on error
                    if (!startTime) startTime = '2000-01-01T00:00:00Z';
                    if (!endTime) endTime = new Date().toISOString();
                    
                    fetch('/api/request-history', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            nodeId: nodeId,
                            startTime: startTime,
                            endTime: endTime
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert(`Time-based request submitted. Request ID: ${data.requestId}`);
                            setTimeout(updateSyncStatus, 2000);
                        } else {
                            alert(`Error: ${data.error}`);
                        }
                    })
                    .catch(error => {
                        console.error('Error requesting historical data:', error);
                        alert('Error requesting historical data. Check console for details.');
                    });
                });
        }
        
        // Update sync interval
        function updateInterval() {
            const intervalSeconds = document.getElementById('syncInterval').value;
            const intervalMs = intervalSeconds * 1000;
            
            if (intervalSeconds < 5) {
                alert('Sync interval must be at least 5 seconds');
                return;
            }
            
            fetch('/api/sync-interval', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    interval: intervalMs
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`Sync interval updated to ${intervalSeconds} seconds`);
                    updateSyncStatus();
                } else {
                    alert(`Error: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error updating sync interval:', error);
                alert('Error updating sync interval. Check console for details.');
            });
        }

        // Helper function to format uptime
        function formatUptime(startTime) {
            const start = new Date(startTime);
            const now = new Date();
            const diff = now - start;
            
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            
            return `${days}d ${hours}h ${minutes}m`;
        }

        // Helper function to format date
        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp);
            
            // Return ISO date without milliseconds
            return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
        }
        
        // Graph functions
        function fetchAndUpdateChart(nodeId, type) {
            if (!nodeId) return;
            
            const timeRange = document.getElementById('timeRange').value;
            const points = document.getElementById('points').value;
            const now = new Date();
            const startDate = new Date(now.getTime() - (timeRange * 3600 * 1000)).toISOString();
            
            // Build URL for the chart data using the binned endpoint
            const url = new URL('/api/sensor-data/binned', window.location.origin);
            url.searchParams.set('node_id', nodeId);
            url.searchParams.set('reading_type', type);
            url.searchParams.set('start_time', startDate);
            url.searchParams.set('bin_count', points);
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    // Destroy existing chart if it exists
                    if (type === 'temperature' && tempChart) {
                        tempChart.destroy();
                    } else if (type === 'humidity' && humidityChart) {
                        humidityChart.destroy();
                    }
                    
                    // No data
                    if (!data || data.length === 0) {
                        document.getElementById(type === 'temperature' ? 'tempChart' : 'humidityChart')
                            .parentElement.innerHTML = `<div class="no-data" style="display:flex; justify-content:center; align-items:center; height:300px; color:var(--text-secondary);">No ${type} data available for selected period</div>`;
                        return;
                    }
                    
                    // Create new chart
                    const ctx = document.getElementById(type === 'temperature' ? 'tempChart' : 'humidityChart').getContext('2d');
                    const chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.map(row => new Date(row.timestamp).toLocaleString()),
                            datasets: [{
                                label: type === 'temperature' ? 'Temperature (째F)' : 'Humidity (%)',
                                data: data.map(row => row.value),
                                borderColor: type === 'temperature' ? 'rgb(255, 99, 132)' : 'rgb(54, 162, 235)',
                                backgroundColor: type === 'temperature' ? 'rgba(255, 99, 132, 0.1)' : 'rgba(54, 162, 235, 0.1)',
                                tension: 0.1,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            spanGaps: false, // Don't connect null values
                            elements: {
                                line: {
                                    tension: 0.1 // Smoother curves
                                },
                                point: {
                                    radius: 3 // Make points more visible
                                }
                            },
                            plugins: {
                                legend: {
                                    labels: {
                                        color: '#e8e6e3'
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.raw;
                                            if (value === null) return 'No data';
                                            return type === 'temperature' 
                                                ? `${value.toFixed(1)}째F` 
                                                : `${value.toFixed(1)}%`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: '#e8e6e3'
                                    }
                                },
                                y: {
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: '#e8e6e3'
                                    },
                                    title: {
                                        display: true,
                                        text: type === 'temperature' ? 'Temperature (째F)' : 'Humidity (%)',
                                        color: '#e8e6e3'
                                    }
                                }
                            }
                        }
                    });
                    
                    // Store reference to the new chart
                    if (type === 'temperature') {
                        tempChart = chart;
                    } else {
                        humidityChart = chart;
                    }
                })
                .catch(error => console.error(`Error fetching ${type} data:`, error));
        }
        
        // Bin data into the requested number of points (client-side binning not needed with binned API)
        function binData(data, binCount) {
            // Server does the binning now
            return data;
        }
        
        // Update charts
        function updateCharts() {
            const nodeId = document.getElementById('nodeSelect').value;
            
            if (!nodeId) {
                alert('Please select a node to display data');
                return;
            }
            
            fetchAndUpdateChart(nodeId, 'temperature');
            fetchAndUpdateChart(nodeId, 'humidity');
        }

        // Update information only on load and with manual refresh
        setTimeout(() => {
            // Initial load
            updateServerInfo();
            updateConnectedNodes();
            updateSyncStatus();
            updateSyncDetails();
            
            // Add very infrequent background updates
            setInterval(updateServerInfo, 60000); // Every 60 seconds
        }, 1000);
        
        // Add manual refresh button to header of each section
        document.addEventListener('DOMContentLoaded', function() {
            // Add refresh buttons to all containers
            const containers = document.querySelectorAll('.container');
            containers.forEach(container => {
                const headerRow = container.querySelector('.header-row');
                if (headerRow) {
                    // Create refresh button
                    const refreshBtn = document.createElement('button');
                    refreshBtn.innerHTML = '';
                    refreshBtn.className = 'refresh-button';
                    refreshBtn.title = 'Refresh';
                    refreshBtn.style.cssText = 'background: none; color: var(--text-secondary); border: none; font-size: 1.2rem; cursor: pointer; margin-left: 0.5rem;';
                    
                    // Add hover effect
                    refreshBtn.addEventListener('mouseover', function() {
                        this.style.color = 'var(--text-primary)';
                    });
                    refreshBtn.addEventListener('mouseout', function() {
                        this.style.color = 'var(--text-secondary)';
                    });
                    
                    // Add click handler based on container content
                    refreshBtn.addEventListener('click', function() {
                        const title = headerRow.querySelector('h2')?.textContent || '';
                        
                        if (title.includes('Server Information')) {
                            updateServerInfo();
                        } else if (title.includes('Connected Nodes')) {
                            updateConnectedNodes();
                        } else if (title.includes('Node Graph')) {
                            updateCharts();
                        } else if (title.includes('Data Synchronization')) {
                            updateSyncStatus();
                            updateSyncDetails();
                        } else if (title.includes('Updates')) {
                            // Just show success message in log
                            addLogEntry('Refreshed updates section', 'info');
                        }
                        
                        // Show refresh indicator
                        this.innerHTML = '';
                        this.classList.add('rotating');
                        setTimeout(() => {
                            this.innerHTML = '';
                            this.classList.remove('rotating');
                        }, 500);
                    });
                    
                    // Add CSS for rotation animation
                    if (!document.getElementById('rotation-style')) {
                        const style = document.createElement('style');
                        style.id = 'rotation-style';
                        style.textContent = `
                            @keyframes rotation {
                                from { transform: rotate(0deg); }
                                to { transform: rotate(360deg); }
                            }
                            .rotating {
                                animation: rotation 0.5s linear;
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // Add button to header
                    const existingButton = headerRow.querySelector('button:not(.refresh-button)');
                    if (existingButton) {
                        headerRow.insertBefore(refreshBtn, existingButton);
                    } else {
                        headerRow.appendChild(refreshBtn);
                    }
                }
            });
            
            // Add event listeners for action buttons
            document.getElementById('updateSyncInterval')?.addEventListener('click', updateInterval);
            document.getElementById('updateGraphButton')?.addEventListener('click', updateCharts);
            document.getElementById('resetPendingButton')?.addEventListener('click', resetPendingRequests);
            document.getElementById('updateBatchSize')?.addEventListener('click', updateBatchSize);
        });

        // Log window functionality
        const logWindow = document.getElementById('logWindow');
        const clearLogsButton = document.getElementById('clearLogsButton');
        
        // Maximum number of log entries to keep in the log window
        const maxLogEntries = 1000;
        
        // Function to add a log entry
        function addLogEntry(message, type = 'info', nodeId = null) {
            const now = new Date();
            const timestamp = now.toISOString().substring(0, 19).replace('T', ' ');
            const logEntry = document.createElement('div');
            
            // Set color based on log type
            let color = 'var(--text-primary)'; // default
            if (type === 'error') color = 'var(--error-color)';
            if (type === 'success') color = 'var(--success-color)';
            if (type === 'warning' || type === 'warn') color = 'var(--active-color)';
            
            // Don't include nodeId as part of the message, it's already formatted into the message
            logEntry.innerHTML = `<span style="color: var(--text-secondary)">[${timestamp}]</span> <span style="color: ${color}">${message}</span>`;
            logWindow.appendChild(logEntry);
            
            // Auto-scroll to bottom
            logWindow.scrollTop = logWindow.scrollHeight;
            
            // Limit to maxLogEntries to prevent memory issues
            while (logWindow.children.length > maxLogEntries) {
                logWindow.removeChild(logWindow.firstChild);
            }
        }
        
        // Clear logs button handler
        clearLogsButton.addEventListener('click', () => {
            logWindow.innerHTML = '';
            addLogEntry('Logs cleared', 'info');
        });
        
        // Initial log entry
        addLogEntry('Log window initialized', 'success');
        
        // Connect to Socket.IO for real-time server events
        const socket = io({
            path: '/socket.io',
            transports: ['websocket', 'polling'],  // Use both websocket and polling
            reconnectionAttempts: 5,
            timeout: 20000,
            reconnectionDelay: 1000,
            forceNew: true
        });
        
        // Add socket connection event handlers
        socket.on('connect', () => {
            console.log('Socket.IO connected successfully');
            addLogEntry('Socket.IO connected to server', 'success');
        });
        
        socket.on('connect_error', (error) => {
            console.error('Socket.IO connection error:', error);
            addLogEntry(`Socket.IO connection error: ${error.message}`, 'error');
        });
        
        socket.on('disconnect', (reason) => {
            console.warn('Socket.IO disconnected:', reason);
            addLogEntry(`Socket.IO disconnected: ${reason}`, 'warn');
        });
        
        socket.on('reconnect', (attempt) => {
            console.log(`Socket.IO reconnected after ${attempt} attempts`);
            addLogEntry(`Socket.IO reconnected after ${attempt} attempts`, 'success');
        });
        
        // Listen for server events
        socket.on('serverEvent', (data) => {
            // Map 'success' level to 'info' for display purposes (since our CSS doesn't have a success class)
            const displayLevel = data.level === 'success' ? 'info' : data.level;
            const nodeInfo = data.nodeId ? `[${data.nodeId}] ` : '';
            
            // Format context if available
            let contextInfo = '';
            if (data.context) {
                try {
                    // If context is a string, try to parse it as JSON
                    const ctx = typeof data.context === 'string' ? JSON.parse(data.context) : data.context;
                    
                    // Include requestId if available
                    if (ctx.requestId) {
                        contextInfo = ` (Request: ${ctx.requestId})`;
                    }
                    
                    // Include sequence info if available
                    if (ctx.startSequence !== undefined) {
                        const endSeq = ctx.endSequence || 'latest';
                        contextInfo += ` Sequences: ${ctx.startSequence}  ${endSeq}`;
                    }
                    
                    // Include record count if available
                    if (ctx.recordCount !== undefined) {
                        contextInfo += ` (${ctx.recordCount} records)`;
                    }
                } catch (e) {
                    // If parsing fails, use the original context string
                    contextInfo = data.context;
                }
            }
            
            addLogEntry(`${nodeInfo}${data.message}${contextInfo}`, displayLevel, data.nodeId);
        });
        
        // Listen for node connections/disconnections
        fetch('/api/connected-nodes')
            .then(response => response.json())
            .then(nodes => {
                nodes.forEach(node => {
                    addLogEntry(`Node ${node.hostname || node.id} is connected`, 'success', node.id);
                });
            })
            .catch(error => {
                addLogEntry(`Error fetching connected nodes: ${error.message}`, 'error');
            });
        
        // Add handlers for manual actions
        document.addEventListener('click', (event) => {
            // Force sync button clicks
            if (event.target.classList.contains('sync-button')) {
                const nodeId = event.target.getAttribute('data-node-id');
                addLogEntry(`Manually requested sync from node ${nodeId}`, 'info');
            }
        });

        // Function to update sync details
        function updateSyncDetails() {
            fetch('/api/sync-details')
                .then(response => response.json())
                .then(data => {
                    // Update sync status display
                    const statusElement = document.getElementById('syncStatus');
                    
                    // Format status text
                    let statusHtml = `
                        <div>Pending Requests: ${data.pendingCount}</div>
                        <div>Connected Nodes: ${data.connectedCount}</div>
                        <div>Batch Size: ${data.batchSize || '1000'} records</div>
                    `;
                    
                    // Add recent requests if any
                    if (data.recentRequests && data.recentRequests.length > 0) {
                        statusHtml += `<div style="margin-top: 0.5rem;">Recent Requests:</div>`;
                        statusHtml += `<div style="max-height: 200px; overflow-y: auto;">`;
                        data.recentRequests.forEach(req => {
                            const time = formatTimeAgo(req.request_time);
                            const statusClass = 
                                req.status === 'completed' ? 'var(--success-color)' : 
                                req.status === 'pending' ? 'var(--active-color)' : 
                                req.status === 'timeout' ? 'var(--error-color)' : 'var(--text-secondary)';
                            
                            // Add sequence range if available
                            let seqInfo = '';
                            if (req.start_sequence) {
                                seqInfo = ` [${req.start_sequence}  ${req.end_sequence || 'latest'}]`;
                            }
                            
                            statusHtml += `
                                <div style="margin-top: 0.25rem; font-size: 0.9rem;">
                                    <span style="color: ${statusClass}">${req.status}</span> - 
                                    ${req.hostname || req.node_id}${seqInfo} (${time})
                                    ${req.record_count ? ` - ${req.record_count} records`