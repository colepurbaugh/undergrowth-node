<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Undergrowth Node</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="mask-icon" href="/assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="/assets/js/core.js"></script>
</head>
<body class="normal-state" style="background-image: url('/assets/backgrounds/undergrowth_logo.png') !important; background-repeat: no-repeat !important; background-position: top center !important; background-size: 90vh auto !important; background-attachment: fixed !important;">
    <div class="container">
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]" id="nodeHeader">System Information</h2>
            <button id="emergencyButton" class="emergency-button">Emergency Stop</button>
        </div>
        <div class="timezone-section">
            <div class="clock-display">
                <span id="dateDisplay"></span>
                <span id="timeDisplay"></span>
                <span id="timezoneDisplay"></span>
            </div>
            <div class="timezone-controls">
                <select id="timezoneSelect">
                    <!-- US Timezones -->
                    <option value="America/New_York">ET</option>
                    <option value="America/Chicago">CT</option>
                    <option value="America/Denver">MT</option>
                    <option value="America/Los_Angeles">PT</option>
                    <option value="America/Anchorage">AKT</option>
                    <option value="Pacific/Honolulu">HT</option>
                    <!-- UTC Offsets -->
                    <option value="UTC">UTC</option>
                    <option value="UTC+1">UTC+1</option>
                    <option value="UTC+2">UTC+2</option>
                    <option value="UTC+3">UTC+3</option>
                    <option value="UTC+4">UTC+4</option>
                    <option value="UTC+5">UTC+5</option>
                    <option value="UTC+6">UTC+6</option>
                    <option value="UTC+7">UTC+7</option>
                    <option value="UTC+8">UTC+8</option>
                    <option value="UTC+9">UTC+9</option>
                    <option value="UTC+10">UTC+10</option>
                    <option value="UTC+11">UTC+11</option>
                    <option value="UTC+12">UTC+12</option>
                    <option value="UTC-1">UTC-1</option>
                    <option value="UTC-2">UTC-2</option>
                    <option value="UTC-3">UTC-3</option>
                    <option value="UTC-4">UTC-4</option>
                    <option value="UTC-5">UTC-5</option>
                    <option value="UTC-6">UTC-6</option>
                    <option value="UTC-7">UTC-7</option>
                    <option value="UTC-8">UTC-8</option>
                    <option value="UTC-9">UTC-9</option>
                    <option value="UTC-10">UTC-10</option>
                    <option value="UTC-11">UTC-11</option>
                    <option value="UTC-12">UTC-12</option>
                </select>
                <button id="updateTimezone">Update Timezone</button>
            </div>
        </div>
    
        <div class="nav-buttons">
            <a href="/pwm" class="nav-button pwm">PWM & Schedule</a>
            <a href="/graph" class="nav-button graph">Graph</a>
        </div>
        <div class="info-section">
            <div class="info-item">
                <div class="info-label">Pi Uptime:</div>
                <div class="info-value" id="piUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Server Uptime:</div>
                <div class="info-value" id="serverUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">IP Address:</div>
                <div class="info-value" id="ipAddress">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">MAC Address:</div>
                <div class="info-value" id="macAddress">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Hostname:</div>
                <div class="info-value" id="hostname">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">CPU Temperature:</div>
                <div class="info-value" id="cpuTemp">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Internet Status:</div>
                <div class="info-value" id="internetStatus">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Last Time Sync:</div>
                <div class="info-value" id="clockStatus">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">System Timezone:</div>
                <div class="info-value" id="systemTimezone">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Database Timezone:</div>
                <div class="info-value" id="databaseTimezone">Loading...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Sensors</h2>
        <div class="info-section" id="sensors-container">
            <!-- Add New Sensor card fixed at beginning -->
            <div class="sensor-card" id="add-sensor-card">
                <div class="sensor-header">
                    <div class="sensor-title">Add New Sensor</div>
                </div>
                <div class="sensor-controls vertical">
                    <select id="sensorTypeSelect" class="sensor-select">
                        <option value="" disabled selected>Select sensor type</option>
                        <option value="0x38-AHT10">0x38-AHT10</option>
                        <option value="0x39-AHT10">0x39-AHT10</option>
                        <option value="0x38-AHT20">0x38-AHT20</option>
                        <option value="0x77-BME688">0x77-BME688</option>
                        <option value="0x76-BME688">0x76-BME688</option>
                        <option value="0x28-CC2A33">0x28-CC2A33</option>
                    </select>
                    <button id="addSensorButton" class="add-sensor-button">+ Add Sensor</button>
                </div>
            </div>
            <!-- Dynamic sensor content will be loaded here -->
        </div>
    </div>

    <div class="container">
        <h2>Data Synchronization</h2>
        <div class="info-section">
            <div class="sync-info-item">
                <div class="sync-node-info">node-<span id="nodeIdDisplay">--</span> (<span id="nodeIpDisplay">--</span>)</div>
                <div class="sync-server-info">server-<span id="serverIdDisplay">--</span> (<span id="serverIpDisplay">--</span>)</div>
                <div class="sync-timestamp">Last Sync: <span id="lastSyncTime">--/--/-- --:--:--</span></div>
                <div class="sync-counts">
                    <div>Local: <span id="nodeTotalRecords">0</span></div>
                    <div>Server: <span id="serverRecordCount">0</span></div>
                </div>
                <div class="sync-progress-container">
                    <div class="sync-progress-bar">
                        <div id="syncProgressFill" class="sync-progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="sync-percentage"><span id="syncPercentage">0</span>% Synched</div>
                </div>
                <div id="serverConnectionStatus" class="sync-connection-status"></div>
            </div>
        </div>
    </div>
    
    <style>
        /* Sensor Card Updates */
        .sensor-readings {
            font-family: monospace;
            font-size: 1.1rem;
            margin: 10px 0;
            color: var(--text-primary);
            text-align: center;
        }

        .sensor-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }

        .sensor-stat {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
        }

        /* Sync Section */
        .sync-info-item {
            width: 100%;
            padding: 15px;
            background-color: #333;
            opacity: 0.8;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
        }

        .sync-node-info, .sync-server-info, .sync-timestamp {
            font-family: monospace;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .sync-counts {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
            margin: 10px 0;
        }

        .sync-progress-container {
            margin-top: 10px;
        }

        .sync-progress-bar {
            height: 20px;
            background-color: #222;
            border-radius: 10px;
            overflow: hidden;
        }

        .sync-progress-fill {
            height: 100%;
            background-color: var(--success-color);
        }

        .sync-percentage {
            text-align: center;
            margin-top: 5px;
            font-family: monospace;
        }
        
        .sync-connection-status {
            margin-top: 10px;
            font-style: italic;
            text-align: center;
        }

        /* Database Info Section */
        .database-info-item {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            background-color: #333;
            opacity: 0.8;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            margin-bottom: 10px;
        }

        .database-header {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .database-content {
            margin-top: 10px;
        }

        .database-section {
            margin-bottom: 15px;
        }

        .section-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .command-box {
            background-color: #222;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .command-box code {
            font-family: monospace;
            color: var(--text-primary);
            white-space: nowrap;
        }
    </style>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentTimezone = 'America/Los_Angeles';
        let brokerInfo = {
            address: null,
            port: null,
            subscribedTopics: []
        };
        let sensors = []; // Store sensor configurations
        let sensorData = {}; // Store the latest sensor readings
        
        // Define custom handler for initial state data
        function onInitialState(data) {
            // Update system information and other data
            if (data.system) {
                document.getElementById('piUptime').textContent = data.system.piUptime;
                document.getElementById('serverUptime').textContent = data.system.serverUptime;
                document.getElementById('ipAddress').textContent = data.system.ipAddress;
                document.getElementById('macAddress').textContent = data.system.macAddress;
                document.getElementById('hostname').textContent = data.system.hostname;
                document.getElementById('cpuTemp').textContent = data.system.cpuTemp;
                
                // Update header with hostname and IP address
                const hostname = data.system.hostname || '';
                const ipAddress = data.system.ipAddress || '';
                // Extract the last part of the hostname and the last octet of the IP
                const hostnameShort = hostname.split('-').pop() || '';
                const ipOctet = ipAddress.split('.').pop() || '';
                if (hostnameShort && ipOctet) {
                    document.getElementById('nodeHeader').textContent = `${hostnameShort}.${ipOctet}`;
                    document.getElementById('nodeIdDisplay').textContent = hostnameShort;
                }
                
                // Update internet status with color coding
                const internetStatusElement = document.getElementById('internetStatus');
                if (internetStatusElement) {
                    internetStatusElement.textContent = data.system.internetStatus;
                    internetStatusElement.style.color = data.system.internetConnected ? 
                        'var(--success-color)' : 'var(--error-color)';
                }
                
                // Update clock status
                const clockStatusElement = document.getElementById('clockStatus');
                if (clockStatusElement) {
                    clockStatusElement.textContent = data.system.timeSinceSync;
                }
                
                // Update system timezone
                const systemTimezoneElement = document.getElementById('systemTimezone');
                if (systemTimezoneElement && data.system.systemTimezone) {
                    systemTimezoneElement.textContent = formatTimezoneDisplay(data.system.systemTimezone);
                }
            }
            
            // Update database timezone
            const databaseTimezoneElement = document.getElementById('databaseTimezone');
            if (databaseTimezoneElement && data.databaseTimezone) {
                databaseTimezoneElement.textContent = formatTimezoneDisplay(data.databaseTimezone);
            }

            // Store sensor data for legacy sensors (0x38 and 0x39) to support existing code
            if (data.sensor1) {
                sensorData['0x38'] = {
                    address: data.sensor1.address,
                    temperature: data.sensor1.temperature,
                    humidity: data.sensor1.humidity
                };
            }

            if (data.sensor2) {
                sensorData['0x39'] = {
                    address: data.sensor2.address,
                    temperature: data.sensor2.temperature,
                    humidity: data.sensor2.humidity
                };
            }
            
            // After receiving initial state, request configured sensors
            socket.emit('getSensors');
        }
        
        // Function to fetch and update sequence data
        function fetchSequenceData() {
            fetch('/api/sequence-info')
                .then(response => response.json())
                .then(data => {
                    console.log('Sequence data:', data);
                    
                    // Update node sequence information
                    if (data.nodeSequence) {
                        document.getElementById('nodeTotalRecords').textContent = data.nodeSequence.count.toLocaleString();
                        
                        // Update node IP if available
                        const nodeIpElement = document.getElementById('nodeIpDisplay');
                        const ipAddress = document.getElementById('ipAddress').textContent || '--';
                        if (nodeIpElement && ipAddress !== 'Loading...') {
                            nodeIpElement.textContent = ipAddress;
                        }
                        
                        // Update last timestamp as the "Last Sync" time locally
                        if (data.nodeSequence.lastTimestamp) {
                            document.getElementById('lastSyncTime').textContent = formatDateTime(data.nodeSequence.lastTimestamp);
                        }
                    }
                    
                    if (data.serverSync) {
                        // Get server information
                        const serverIdDisplay = document.getElementById('serverIdDisplay');
                        serverIdDisplay.textContent = data.serverSync.server_id || '--';
                        
                        // Update server IP if broker info is available
                        const serverIpDisplay = document.getElementById('serverIpDisplay');
                        if (brokerInfo && brokerInfo.address) {
                            serverIpDisplay.textContent = brokerInfo.address;
                        }
                        
                        // Get last synced value timestamp
                        const lastSyncedTimestamp = formatDateTime(data.serverSync.lastSyncedTimestamp || 'Never');
                        document.getElementById('lastSyncTime').textContent = lastSyncedTimestamp;
                        
                        // Update server record count
                        const synchedValues = data.serverSync.sentCount ? data.serverSync.sentCount.toLocaleString() : '0';
                        document.getElementById('serverRecordCount').textContent = synchedValues;
                        
                        // Calculate and update sync percentage
                        const localCount = data.nodeSequence ? data.nodeSequence.count : 0;
                        const serverCount = data.serverSync.sentCount || 0;
                        
                        let syncPercentage = 0;
                        if (localCount > 0) {
                            syncPercentage = Math.floor((serverCount / localCount) * 100);
                        }
                        
                        document.getElementById('syncPercentage').textContent = syncPercentage;
                        document.getElementById('syncProgressFill').style.width = `${syncPercentage}%`;
                        
                        // Update connection status
                        const serverConnectionStatus = document.getElementById('serverConnectionStatus');
                        if (brokerInfo && brokerInfo.address) {
                            serverConnectionStatus.textContent = 'Connected to MQTT Broker';
                            serverConnectionStatus.style.color = 'var(--success-color)';
                        } else {
                            serverConnectionStatus.textContent = 'Disconnected from MQTT Broker';
                            serverConnectionStatus.style.color = 'var(--error-color)';
                        }
                    } else {
                        // Default values if no server sync info
                        document.getElementById('serverIdDisplay').textContent = '--';
                        document.getElementById('serverIpDisplay').textContent = '--';
                        document.getElementById('serverRecordCount').textContent = '0';
                        document.getElementById('syncPercentage').textContent = '0';
                        document.getElementById('syncProgressFill').style.width = '0%';
                        
                        const serverConnectionStatus = document.getElementById('serverConnectionStatus');
                        serverConnectionStatus.textContent = 'Server connection not established';
                        serverConnectionStatus.style.color = 'var(--error-color)';
                    }
                })
                .catch(error => {
                    console.error('Error fetching sequence data:', error);
                    
                    // Set default values on error
                    document.getElementById('serverIdDisplay').textContent = '--';
                    document.getElementById('serverIpDisplay').textContent = '--';
                    document.getElementById('serverRecordCount').textContent = '0';
                    document.getElementById('syncPercentage').textContent = '0';
                    document.getElementById('syncProgressFill').style.width = '0%';
                    
                    const serverConnectionStatus = document.getElementById('serverConnectionStatus');
                    serverConnectionStatus.textContent = 'Error fetching server information';
                    serverConnectionStatus.style.color = 'var(--error-color)';
                });
        }
        
        // New function to fetch and update sensor statistics efficiently
        let lastSensorStatsFetch = 0;
        let sensorStatsCache = {};
        
        function fetchSensorStats() {
            const now = Date.now();
            // Only fetch every 10 seconds to reduce database load
            if (now - lastSensorStatsFetch < 10000 && Object.keys(sensorStatsCache).length > 0) {
                updateSensorStatsUI(sensorStatsCache);
                return;
            }
            
            fetch('/api/sensor-stats/summary')
                .then(response => response.json())
                .then(data => {
                    // Update last fetch time
                    lastSensorStatsFetch = now;
                    sensorStatsCache = data;
                    
                    // Update UI with received data
                    updateSensorStatsUI(data);
                    
                    // Update Database Information section with current stats
                    updateDatabaseInfoSection(data);
                })
                .catch(error => {
                    console.error('Error fetching sensor statistics:', error);
                });
        }
        
        function updateSensorStatsUI(data) {
            if (!data.sensors || !data.sensors.length) return;
            
            console.log('Updating sensor stats UI with data:', data);
            
            // Process each sensor
            data.sensors.forEach(sensorStat => {
                // Legacy sensors have special handling
                let sensorId = sensorStat.id;
                
                // Convert legacy sensor IDs to match the DOM elements
                if (sensorStat.deviceId === 'sensor1' || sensorStat.address === '0x38') {
                    sensorId = '1';
                } else if (sensorStat.deviceId === 'sensor2' || sensorStat.address === '0x39') {
                    sensorId = '2';
                }
                
                console.log(`Processing sensor ${sensorId} (${sensorStat.address}) - Stats: temp=${sensorStat.temperatureCount}, humid=${sensorStat.humidityCount}, total=${sensorStat.totalCount}`);
                
                // Find corresponding DOM elements
                const firstRecordElem = document.querySelector(`.sensor-first-record[data-id="${sensorId}"]`);
                const recordCountElem = document.querySelector(`.sensor-record-count[data-id="${sensorId}"]`);
                
                if (!firstRecordElem || !recordCountElem) {
                    console.warn(`Could not find elements for sensor ${sensorId}`);
                }
                
                // Update first timestamp (won't change)
                if (firstRecordElem && sensorStat.firstTimestamp) {
                    firstRecordElem.textContent = formatDateTime(sensorStat.firstTimestamp);
                    // Store in data attribute to avoid re-fetching
                    firstRecordElem.dataset.timestamp = sensorStat.firstTimestamp;
                } else if (firstRecordElem) {
                    // No timestamp available
                    firstRecordElem.textContent = 'No data';
                }
                
                // Update record count
                if (recordCountElem) {
                    recordCountElem.textContent = sensorStat.totalCount ? 
                        sensorStat.totalCount.toLocaleString() : '0';
                }
            });
            
            // Update total record count in Database Information section
            const totalDbRecordsElem = document.getElementById('totalDbRecords');
            if (totalDbRecordsElem) {
                totalDbRecordsElem.textContent = data.totalRecordCount ? 
                    data.totalRecordCount.toLocaleString() : '0';
            }
        }
        
        function updateDatabaseInfoSection(data) {
            // Find or create elements for database stats
            let totalDbRecordsElem = document.getElementById('totalDbRecords');
            let dbStatsContainer = document.getElementById('dbStatsContainer');
            
            // Create elements if they don't exist
            if (!dbStatsContainer) {
                // Find the command box to insert before
                const firstCommandBox = document.querySelector('.database-info-item:nth-child(2) .command-box');
                if (firstCommandBox) {
                    // Create stats container
                    dbStatsContainer = document.createElement('div');
                    dbStatsContainer.id = 'dbStatsContainer';
                    dbStatsContainer.className = 'database-section';
                    
                    // Create section title
                    const sectionTitle = document.createElement('div');
                    sectionTitle.className = 'section-title';
                    sectionTitle.textContent = 'Current Statistics';
                    dbStatsContainer.appendChild(sectionTitle);
                    
                    // Create stats display
                    const statsDisplay = document.createElement('div');
                    statsDisplay.className = 'database-stats';
                    statsDisplay.innerHTML = `
                        <div>Total Records: <span id="totalDbRecords">0</span></div>
                        <div>Last Updated: <span id="dbStatsUpdated">--</span></div>
                    `;
                    dbStatsContainer.appendChild(statsDisplay);
                    
                    // Insert container before the command box
                    firstCommandBox.parentNode.insertBefore(dbStatsContainer, firstCommandBox);
                    
                    // Get the newly created element
                    totalDbRecordsElem = document.getElementById('totalDbRecords');
                }
            }
            
            // Update stats if elements exist
            if (totalDbRecordsElem) {
                totalDbRecordsElem.textContent = data.totalRecordCount ? 
                    data.totalRecordCount.toLocaleString() : '0';
            }
            
            const dbStatsUpdatedElem = document.getElementById('dbStatsUpdated');
            if (dbStatsUpdatedElem) {
                dbStatsUpdatedElem.textContent = formatDateTime(data.timestamp);
            }
        }
        
        // Helper function to update broker info display
        function updateBrokerInfoDisplay() {
            console.log('Updating broker info display with:', brokerInfo);
            
            const serverConnectionStatus = document.getElementById('serverConnectionStatus');
            if (!serverConnectionStatus) {
                console.warn('serverConnectionStatus element not found');
                return;
            }
            
            if (brokerInfo && brokerInfo.address) {
                // We have broker information
                const status = brokerInfo.connected ? 'Connected' : 'Discovered but not connected';
                serverConnectionStatus.textContent = `MQTT Broker: ${status} (${brokerInfo.address}:${brokerInfo.port})`;
                serverConnectionStatus.style.color = brokerInfo.connected ? 
                    'var(--success-color)' : 'var(--active-color)';
                
                // Update server IP in sync section if available
                const serverIpDisplay = document.getElementById('serverIpDisplay');
                if (serverIpDisplay) {
                    serverIpDisplay.textContent = brokerInfo.address;
                }
            } else {
                // No broker information
                serverConnectionStatus.textContent = 'MQTT Broker: Not discovered';
                serverConnectionStatus.style.color = 'var(--error-color)';
            }
        }
        
        // Update broker information
        socket.on('brokerInfo', (data) => {
            console.log('Received broker info:', data);
            
            // Store broker information for display
            brokerInfo = {
                connected: data.connected === true, // Ensure this is a boolean
                address: data.address || null,
                port: data.port || '1883',
                subscribedTopics: data.subscribedTopics || []
            };
            
            // Update the display immediately
            updateBrokerInfoDisplay();
            
            // If we have broker info but no connection yet, attempt to fetch sequence data right away
            if (brokerInfo.address && document.getElementById('serverIpDisplay').textContent === '--') {
                fetchSequenceData();
            }
        });
        
        // Helper function to format date/time
        function formatDateTime(timestamp) {
            if (!timestamp || timestamp === 'Never') return 'Never';
            
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                year: '2-digit',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
        
        function updateClock() {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                month: 'long',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZoneName: 'short'
            });
            
            const parts = formatter.formatToParts(now);
            const date = parts.find(p => p.type === 'month').value + ' ' +
                        parts.find(p => p.type === 'day').value + ' ' +
                        parts.find(p => p.type === 'year').value;
            const time = parts.find(p => p.type === 'hour').value + ':' +
                        parts.find(p => p.type === 'minute').value + ':' +
                        parts.find(p => p.type === 'second').value;
            const timezone = parts.find(p => p.type === 'timeZoneName').value;
            
            const dateDisplay = document.getElementById('dateDisplay');
            const timeDisplay = document.getElementById('timeDisplay');
            const timezoneDisplay = document.getElementById('timezoneDisplay');
            
            if (dateDisplay && timeDisplay && timezoneDisplay) {
                dateDisplay.textContent = date + ', ';
                timeDisplay.textContent = time;
                timezoneDisplay.textContent = ' (' + timezone + ')';
            }
        }

        // Sensor management functions
        function renderSensors() {
            const container = document.getElementById('sensors-container');
            
            // Keep the add sensor card and remove everything else
            const addSensorCard = document.getElementById('add-sensor-card');
            container.innerHTML = '';
            container.appendChild(addSensorCard);
            
            if (sensors.length === 0) {
                container.appendChild(document.createElement('div')).className = 'empty-state';
                container.lastChild.textContent = 'No sensors configured yet. Add a sensor to get started.';
                return;
            }
            
            // Sort sensors by ID for consistent ordering
            sensors.sort((a, b) => a.id - b.id);
            
            sensors.forEach(sensor => {
                // Get sensor data if available
                const data = sensorData[sensor.address] || {};
                
                // Create sensor card
                const card = document.createElement('div');
                card.className = `sensor-card ${sensor.enabled ? '' : 'disabled'}`;
                card.dataset.id = sensor.id;
                card.dataset.address = sensor.address;
                
                // Parse type and address from sensor type field
                const [address, type] = sensor.address.includes('-') ? 
                    [sensor.address.split('-')[0], sensor.address.split('-')[1]] : 
                    [sensor.address, sensor.type];
                
                // Format temperature and humidity
                const tempFormatted = data.temperature || 'Waiting...';
                const humidityFormatted = data.humidity ? `${data.humidity.toFixed(1)}%` : 'Waiting...';
                
                card.innerHTML = `
                    <div class="sensor-header">
                        <div class="sensor-title">${type} ${address}</div>
                        <div class="sensor-toggle">
                            <span>${sensor.enabled ? 'Enabled' : 'Disabled'}</span>
                            <label class="switch">
                                <input type="checkbox" class="toggle-sensor" ${sensor.enabled ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="sensor-data">
                        <div class="sensor-readings">
                            <span class="temp-value" data-address="${sensor.address}">${tempFormatted}</span>
                            <span class="humidity-value" data-address="${sensor.address}">${humidityFormatted}</span>
                        </div>
                    </div>
                    <div class="sensor-stats">
                        <div class="sensor-stat">
                            <span>Since:</span>
                            <span class="sensor-first-record" data-id="${sensor.id}">--/--/-- --:--:--</span>
                        </div>
                        <div class="sensor-stat">
                            <span>Records:</span>
                            <span class="sensor-record-count" data-id="${sensor.id}">0</span>
                        </div>
                    </div>
                    <div class="sensor-actions">
                        <button class="delete-sensor">Remove</button>
                    </div>
                `;
                
                // Add event listeners
                const toggleBtn = card.querySelector('.toggle-sensor');
                if (toggleBtn) {
                    toggleBtn.addEventListener('change', function() {
                        toggleSensor(sensor.id, this.checked);
                    });
                }
                
                const deleteBtn = card.querySelector('.delete-sensor');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', function() {
                        if (confirm(`Are you sure you want to remove ${type} ${address}?`)) {
                            deleteSensor(sensor.id);
                        }
                    });
                }
                
                container.appendChild(card);
            });
        }
        
        function addSensor() {
            const select = document.getElementById('sensorTypeSelect');
            const sensorTypeValue = select.value;
            
            if (!sensorTypeValue) {
                alert('Please select a sensor type');
                return;
            }
            
            // Check if this sensor already exists
            const [address, type] = sensorTypeValue.split('-');
            const existing = sensors.find(s => s.address === address && s.type === type);
            
            if (existing) {
                alert(`A sensor with address ${address} is already configured`);
                return;
            }
            
            // Add the sensor via socket
            socket.emit('addSensor', {
                address,
                type,
                name: `${type} ${address}`
            });
            
            // Reset the select
            select.value = '';
        }
        
        function toggleSensor(id, enabled) {
            socket.emit('updateSensor', {
                id,
                enabled
            });
        }
        
        function deleteSensor(id) {
            socket.emit('deleteSensor', { id });
        }
        
        // Socket event handlers for sensors
        socket.on('sensorsUpdated', (data) => {
            sensors = data;
            renderSensors();
        });
        
        socket.on('sensorAdded', (sensor) => {
            // Add to local array if not exists
            if (!sensors.find(s => s.id === sensor.id)) {
                sensors.push(sensor);
            }
            renderSensors();
        });
        
        socket.on('sensorUpdated', (sensor) => {
            // Update in local array
            const index = sensors.findIndex(s => s.id === sensor.id);
            if (index !== -1) {
                sensors[index] = sensor;
            }
            renderSensors();
        });
        
        socket.on('sensorDeleted', (data) => {
            // Remove from local array
            sensors = sensors.filter(s => s.id !== data.id);
            renderSensors();
        });
        
        socket.on('sensorError', (data) => {
            alert(`Sensor error: ${data.message}`);
        });

        // Custom initialization for this page
        function customInit() {
            // Update clock every second
            setInterval(updateClock, 1000);
            updateClock(); // Initial update

            // Initialize broker info display to ensure fields are always visible
            updateBrokerInfoDisplay();
            
            // Fetch sequence data every second
            fetchSequenceData(); // Initial fetch
            setInterval(fetchSequenceData, 1000); // Update every second
            
            // Fetch sensor statistics initially and every 10 seconds
            fetchSensorStats(); // Initial fetch
            setInterval(fetchSensorStats, 10000); // Update every 10 seconds

            // Request fresh system information periodically to catch system changes
            setInterval(() => {
                socket.emit('getInitialState');
            }, 30000); // Every 30 seconds

            // Timezone update button
            const updateTimezoneButton = document.getElementById('updateTimezone');
            if (updateTimezoneButton) {
                updateTimezoneButton.addEventListener('click', () => {
                    const timezoneSelect = document.getElementById('timezoneSelect');
                    if (timezoneSelect) {
                        const timezone = timezoneSelect.value;
                        socket.emit('setTimezone', { timezone });
                    }
                });
            }
            
            // Request timezone
            socket.emit('getTimezone');
            
            // Setup "Add Sensor" button
            function setupAddSensorButton() {
                const addSensorButton = document.getElementById('addSensorButton');
                if (addSensorButton) {
                    // Remove any existing event listeners by cloning and replacing
                    const newButton = addSensorButton.cloneNode(true);
                    addSensorButton.parentNode.replaceChild(newButton, addSensorButton);
                    newButton.addEventListener('click', addSensor);
                }
            }
            
            // Setup button initially
            setupAddSensorButton();
            
            // Re-setup button after sensors are rendered
            const originalRenderSensors = renderSensors;
            renderSensors = function() {
                originalRenderSensors();
                setupAddSensorButton();
            };
            
            // Initial load of sensors
            socket.emit('getSensors');
        }

        // Handle timezone updates
        socket.on('timezoneUpdate', (data) => {
            const { timezone } = data;
            const timezoneSelect = document.getElementById('timezoneSelect');
            if (timezoneSelect) {
                timezoneSelect.value = timezone;
            }
            currentTimezone = timezone;
            updateClock();
        });

        socket.on('sensorData', (data) => {
            // Update system information
            document.getElementById('piUptime').textContent = data.system.piUptime;
            document.getElementById('serverUptime').textContent = data.system.serverUptime;
            document.getElementById('ipAddress').textContent = data.system.ipAddress;
            document.getElementById('macAddress').textContent = data.system.macAddress;
            document.getElementById('hostname').textContent = data.system.hostname;
            document.getElementById('cpuTemp').textContent = data.system.cpuTemp;
            
            // Update header with hostname and IP address
            const hostname = data.system.hostname || '';
            const ipAddress = data.system.ipAddress || '';
            // Extract the last part of the hostname and the last octet of the IP
            const hostnameShort = hostname.split('-').pop() || '';
            const ipOctet = ipAddress.split('.').pop() || '';
            if (hostnameShort && ipOctet) {
                document.getElementById('nodeHeader').textContent = `${hostnameShort}.${ipOctet}`;
                document.getElementById('nodeIdDisplay').textContent = hostnameShort;
            }
            
            // Update internet status with color coding
            const internetStatusElement = document.getElementById('internetStatus');
            if (internetStatusElement) {
                internetStatusElement.textContent = data.system.internetStatus;
                internetStatusElement.style.color = data.system.internetConnected ? 
                    'var(--success-color)' : 'var(--error-color)';
            }
            
            // Update clock status
            const clockStatusElement = document.getElementById('clockStatus');
            if (clockStatusElement) {
                clockStatusElement.textContent = data.system.timeSinceSync;
            }
            
            // Update system timezone
            const systemTimezoneElement = document.getElementById('systemTimezone');
            if (systemTimezoneElement && data.system.systemTimezone) {
                systemTimezoneElement.textContent = formatTimezoneDisplay(data.system.systemTimezone);
            }
            
            // Update database timezone
            const databaseTimezoneElement = document.getElementById('databaseTimezone');
            if (databaseTimezoneElement && data.databaseTimezone) {
                databaseTimezoneElement.textContent = formatTimezoneDisplay(data.databaseTimezone);
            }

            // Update sensor data cache
            if (data.sensor1) {
                sensorData['0x38'] = {
                    address: data.sensor1.address,
                    temperature: data.sensor1.temperature,
                    humidity: data.sensor1.humidity
                };
                
                // Update UI for this sensor if it exists
                const tempElements = document.querySelectorAll('.temp-value[data-address="0x38"]');
                const humidityElements = document.querySelectorAll('.humidity-value[data-address="0x38"]');
                
                tempElements.forEach(el => {
                    el.textContent = data.sensor1.temperature;
                });
                
                humidityElements.forEach(el => {
                    el.textContent = `${data.sensor1.humidity.toFixed(1)}%`;
                });
            }

            if (data.sensor2) {
                sensorData['0x39'] = {
                    address: data.sensor2.address,
                    temperature: data.sensor2.temperature,
                    humidity: data.sensor2.humidity
                };
                
                // Update UI for this sensor if it exists
                const tempElements = document.querySelectorAll('.temp-value[data-address="0x39"]');
                const humidityElements = document.querySelectorAll('.humidity-value[data-address="0x39"]');
                
                tempElements.forEach(el => {
                    el.textContent = data.sensor2.temperature;
                });
                
                humidityElements.forEach(el => {
                    el.textContent = `${data.sensor2.humidity.toFixed(1)}%`;
                });
            }
        });

        socket.on('systemState', function(data) {
            // Update modes
            document.getElementById('mode-auto').textContent = data.modes.automatic ? '1' : '0';
            document.getElementById('mode-emergency').textContent = data.modes.emergency ? '1' : '0';

            // Update manual PWM
            Object.entries(data.manualPwm).forEach(([pin, state]) => {
                const element = document.getElementById(`manual-${pin}`);
                if (element) {
                    element.textContent = `{${state.value}, ${state.enabled}}`;
                }
            });

            // Update automatic PWM
            Object.entries(data.autoPwm).forEach(([pin, value]) => {
                const element = document.getElementById(`auto-${pin}`);
                if (element) {
                    element.textContent = value;
                }
            });

            // Update schedule
            Object.entries(data.schedule).forEach(([pin, events]) => {
                const element = document.getElementById(`schedule-${pin}`);
                if (element) {
                    if (events.length === 0) {
                        element.textContent = '-';
                    } else {
                        element.innerHTML = events.map(event => 
                            `<div class="schedule-event ${event.enabled ? 'enabled' : 'disabled'}">
                                {"${event.time}", ${event.value}, ${event.enabled}}
                            </div>`
                        ).join('');
                    }
                }
            });
        });

        // Also update on state changes
        socket.on('stateUpdate', function() {
            socket.emit('getSystemState');
        });

        socket.on('modeUpdate', function() {
            socket.emit('getSystemState');
        });

        // Initialize the application
        initializeApp(socket, customInit);
    </script>
</body>
</html> 