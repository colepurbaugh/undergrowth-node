<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Undergrowth Node</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="mask-icon" href="/assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="/assets/js/core.js"></script>
</head>
<body class="normal-state" style="background-image: url('/assets/backgrounds/undergrowth_logo.png') !important; background-repeat: no-repeat !important; background-position: top center !important; background-size: 90vh auto !important; background-attachment: fixed !important;">
    <div class="container">
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]" id="nodeHeader">System Information</h2>
            <button id="emergencyButton" class="emergency-button">Emergency Stop</button>
        </div>
        <div class="timezone-section">
            <div class="clock-display">
                <span id="dateDisplay"></span>
                <span id="timeDisplay"></span>
                <span id="timezoneDisplay"></span>
            </div>
            <div class="timezone-controls">
                <select id="timezoneSelect">
                    <!-- US Timezones -->
                    <option value="America/New_York">ET</option>
                    <option value="America/Chicago">CT</option>
                    <option value="America/Denver">MT</option>
                    <option value="America/Los_Angeles">PT</option>
                    <option value="America/Anchorage">AKT</option>
                    <option value="Pacific/Honolulu">HT</option>
                    <!-- UTC Offsets -->
                    <option value="UTC">UTC</option>
                    <option value="UTC+1">UTC+1</option>
                    <option value="UTC+2">UTC+2</option>
                    <option value="UTC+3">UTC+3</option>
                    <option value="UTC+4">UTC+4</option>
                    <option value="UTC+5">UTC+5</option>
                    <option value="UTC+6">UTC+6</option>
                    <option value="UTC+7">UTC+7</option>
                    <option value="UTC+8">UTC+8</option>
                    <option value="UTC+9">UTC+9</option>
                    <option value="UTC+10">UTC+10</option>
                    <option value="UTC+11">UTC+11</option>
                    <option value="UTC+12">UTC+12</option>
                    <option value="UTC-1">UTC-1</option>
                    <option value="UTC-2">UTC-2</option>
                    <option value="UTC-3">UTC-3</option>
                    <option value="UTC-4">UTC-4</option>
                    <option value="UTC-5">UTC-5</option>
                    <option value="UTC-6">UTC-6</option>
                    <option value="UTC-7">UTC-7</option>
                    <option value="UTC-8">UTC-8</option>
                    <option value="UTC-9">UTC-9</option>
                    <option value="UTC-10">UTC-10</option>
                    <option value="UTC-11">UTC-11</option>
                    <option value="UTC-12">UTC-12</option>
                </select>
                <button id="updateTimezone">Update Timezone</button>
            </div>
        </div>
    
        <div class="nav-buttons">
            <a href="/schedule" class="nav-button schedule">Schedule</a>
            <a href="/pwm" class="nav-button pwm">PWM</a>
            <a href="/graph" class="nav-button graph">Graph</a>
        </div>
        <div class="info-section">
            <div class="info-item">
                <div class="info-label">Pi Uptime:</div>
                <div class="info-value" id="piUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Server Uptime:</div>
                <div class="info-value" id="serverUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">IP Address:</div>
                <div class="info-value" id="ipAddress">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">MAC Address:</div>
                <div class="info-value" id="macAddress">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Hostname:</div>
                <div class="info-value" id="hostname">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">CPU Temperature:</div>
                <div class="info-value" id="cpuTemp">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Internet Status:</div>
                <div class="info-value" id="internetStatus">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Last Time Sync:</div>
                <div class="info-value" id="clockStatus">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">System Timezone:</div>
                <div class="info-value" id="systemTimezone">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Database Timezone:</div>
                <div class="info-value" id="databaseTimezone">Loading...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Sensors</h2>
        <div class="info-section" id="sensors-container">
            <!-- Add New Sensor card fixed at beginning -->
            <div class="sensor-card" id="add-sensor-card">
                <div class="sensor-header">
                    <div class="sensor-title">Add New Sensor</div>
                </div>
                <div class="sensor-controls vertical">
                    <select id="sensorTypeSelect" class="sensor-select">
                        <option value="" disabled selected>Select sensor type</option>
                        <option value="0x38-AHT10">0x38-AHT10</option>
                        <option value="0x39-AHT10">0x39-AHT10</option>
                        <option value="0x38-AHT20">0x38-AHT20</option>
                        <option value="0x77-BME688">0x77-BME688</option>
                        <option value="0x76-BME688">0x76-BME688</option>
                        <option value="0x28-CC2A33">0x28-CC2A33</option>
                    </select>
                    <button id="addSensorButton" class="add-sensor-button">+ Add Sensor</button>
                </div>
            </div>
            <!-- Dynamic sensor content will be loaded here -->
        </div>
    </div>

    <div class="container">
        <h2>Data Synchronization</h2>
        <div class="info-section">
            <div class="info-item">
                <div class="sync-header">Local Node <span id="nodeIdDisplay">--</span> Values</div>
                <div class="sync-details">
                    <div>First Value: <span id="nodeFirstValueTime">--/--/-- --:--:--</span> (<span id="nodeFirstSequence">0</span>)</div>
                    <div>Latest Value: <span id="nodeLatestValueTime">--/--/-- --:--:--</span> (<span id="nodeLatestSequence">0</span>)</div>
                    <div>Total Values: <span id="nodeTotalRecords">0</span></div>
                </div>
            </div>
            
            <!-- Data flow arrow -->
            <div class="data-flow-arrow">
                <div class="arrow-shaft"></div>
                <div class="arrow-head"></div>
            </div>
            
            <div class="info-item">
                <div id="serverConnectionHeader" class="sync-header">Server Disconnected</div>
                <div id="serverSyncStatus" class="sync-details">
                    <!-- Server connection details will be displayed here -->
                </div>
                <div id="serverBrokerInfo" class="sync-details" style="margin-top: 8px;">
                    <!-- Server broker details will be displayed here -->
                </div>
            </div>
        </div>
    </div>

    <style>
        /* Data flow arrow styles */
        .data-flow-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            margin: 0 10px;
            position: relative;
        }
        
        .arrow-shaft {
            width: 30px;
            height: 8px;
            background-color: var(--success-color);
            position: relative;
        }
        
        .arrow-head {
            width: 0;
            height: 0;
            border-top: 14px solid transparent;
            border-bottom: 14px solid transparent;
            border-left: 14px solid var(--success-color);
            position: absolute;
            right: -4px;
        }
        
        /* On mobile screens, adjust arrow to be vertical */
        @media (max-width: 600px) {
            .data-flow-arrow {
                width: 100%;
                height: 30px;
                margin: 10px 0;
            }
            
            .arrow-shaft {
                width: 8px;
                height: 20px;
            }
            
            .arrow-head {
                border-left: 14px solid transparent;
                border-right: 14px solid transparent;
                border-top: 14px solid var(--success-color);
                border-bottom: none;
                bottom: -4px;
                right: auto;
                top: auto;
                left: -10px;
            }
        }
    </style>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentTimezone = 'America/Los_Angeles';
        let brokerInfo = {
            address: null,
            port: null,
            subscribedTopics: []
        };
        let sensors = []; // Store sensor configurations
        let sensorData = {}; // Store the latest sensor readings
        
        // Define custom handler for initial state data
        function onInitialState(data) {
            // Update system information and other data
            if (data.system) {
                document.getElementById('piUptime').textContent = data.system.piUptime;
                document.getElementById('serverUptime').textContent = data.system.serverUptime;
                document.getElementById('ipAddress').textContent = data.system.ipAddress;
                document.getElementById('macAddress').textContent = data.system.macAddress;
                document.getElementById('hostname').textContent = data.system.hostname;
                document.getElementById('cpuTemp').textContent = data.system.cpuTemp;
                
                // Update header with hostname and IP address
                const hostname = data.system.hostname || '';
                const ipAddress = data.system.ipAddress || '';
                // Extract the last part of the hostname and the last octet of the IP
                const hostnameShort = hostname.split('-').pop() || '';
                const ipOctet = ipAddress.split('.').pop() || '';
                if (hostnameShort && ipOctet) {
                    document.getElementById('nodeHeader').textContent = `${hostnameShort}.${ipOctet}`;
                    document.getElementById('nodeIdDisplay').textContent = hostnameShort;
                }
                
                // Update internet status with color coding
                const internetStatusElement = document.getElementById('internetStatus');
                if (internetStatusElement) {
                    internetStatusElement.textContent = data.system.internetStatus;
                    internetStatusElement.style.color = data.system.internetConnected ? 
                        'var(--success-color)' : 'var(--error-color)';
                }
                
                // Update clock status
                const clockStatusElement = document.getElementById('clockStatus');
                if (clockStatusElement) {
                    clockStatusElement.textContent = data.system.timeSinceSync;
                }
                
                // Update system timezone
                const systemTimezoneElement = document.getElementById('systemTimezone');
                if (systemTimezoneElement && data.system.systemTimezone) {
                    systemTimezoneElement.textContent = formatTimezoneDisplay(data.system.systemTimezone);
                }
            }
            
            // Update database timezone
            const databaseTimezoneElement = document.getElementById('databaseTimezone');
            if (databaseTimezoneElement && data.databaseTimezone) {
                databaseTimezoneElement.textContent = formatTimezoneDisplay(data.databaseTimezone);
            }

            // Store sensor data for legacy sensors (0x38 and 0x39) to support existing code
            if (data.sensor1) {
                sensorData['0x38'] = {
                    address: data.sensor1.address,
                    temperature: data.sensor1.temperature,
                    humidity: data.sensor1.humidity
                };
            }

            if (data.sensor2) {
                sensorData['0x39'] = {
                    address: data.sensor2.address,
                    temperature: data.sensor2.temperature,
                    humidity: data.sensor2.humidity
                };
            }
            
            // After receiving initial state, request configured sensors
            socket.emit('getSensors');
        }
        
        // Function to fetch and update sequence data
        function fetchSequenceData() {
            fetch('/api/sequence-info')
                .then(response => response.json())
                .then(data => {
                    // Update node sequence information
                    if (data.nodeSequence) {
                        document.getElementById('nodeFirstSequence').textContent = data.nodeSequence.minSequence;
                        document.getElementById('nodeLatestSequence').textContent = data.nodeSequence.maxSequence;
                        document.getElementById('nodeTotalRecords').textContent = data.nodeSequence.count.toLocaleString();
                        
                        if (data.nodeSequence.firstTimestamp) {
                            document.getElementById('nodeFirstValueTime').textContent = formatDateTime(data.nodeSequence.firstTimestamp);
                        }
                        if (data.nodeSequence.lastTimestamp) {
                            document.getElementById('nodeLatestValueTime').textContent = formatDateTime(data.nodeSequence.lastTimestamp);
                        }
                    }
                    
                    // Update server sync information (but don't change the connection status)
                    const serverSyncStatus = document.getElementById('serverSyncStatus');
                    const serverBrokerInfo = document.getElementById('serverBrokerInfo');
                    
                    if (data.serverSync) {
                        // Calculate connection duration
                        let connectionDuration = 'Unknown';
                        if (data.serverSync.last_seen) {
                            const lastSeen = new Date(data.serverSync.last_seen);
                            const now = new Date();
                            const diffMs = now - lastSeen;
                            
                            // Format duration
                            const diffMins = Math.floor(diffMs / (1000 * 60));
                            if (diffMins < 60) {
                                connectionDuration = `${diffMins}m`;
                            } else {
                                const diffHours = Math.floor(diffMins / 60);
                                const remainingMins = diffMins % 60;
                                connectionDuration = `${diffHours}h ${remainingMins}m`;
                            }
                        }
                        
                        // Get last synced value timestamp and sequence
                        const lastSyncedTimestamp = formatDateTime(data.serverSync.lastSyncedTimestamp || 'Never');
                        const lastSequence = data.serverSync.last_sequence || 0;
                        const synchedValues = data.serverSync.sentCount ? data.serverSync.sentCount.toLocaleString() : '0';
                        
                        // Get local latest sequence for comparison
                        const latestLocalSequence = data.nodeSequence ? data.nodeSequence.maxSequence : 0;
                        const syncGap = latestLocalSequence - lastSequence;
                        
                        // Move Last Value and Synched Values to broker info section
                        // to ensure they're always visible
                        const mqttAddress = brokerInfo.address ? `${brokerInfo.address}:${brokerInfo.port || '1883'}` : '-';
                        const topics = brokerInfo.subscribedTopics && brokerInfo.subscribedTopics.length > 0 ? 
                            brokerInfo.subscribedTopics.join(', ') : '-';
                        
                        serverBrokerInfo.innerHTML = `
                            <div>MQTT: ${mqttAddress}</div>
                            <div>Last Value: ${lastSyncedTimestamp}</div>
                            <div>Synched Values: ${synchedValues}</div>
                            <div>Topics: ${topics}</div>
                        `;
                        
                        // Create or update remaining server sync information
                        let serverInfoHtml = '';
                        
                        if (data.serverSync.server_id) {
                            serverInfoHtml = `
                                <div>Server <span style="color: var(--success-color)">${data.serverSync.server_id}</span></div>
                                <div>Connection Duration: ${connectionDuration}</div>
                                <div class="sync-gap ${syncGap > 0 ? 'sync-gap-behind' : ''}">
                                    ${syncGap > 0 
                                        ? `Server is ${syncGap.toLocaleString()} values behind` 
                                        : 'Server is up to date'}
                                </div>
                            `;
                        }
                        
                        serverSyncStatus.innerHTML = serverInfoHtml;
                    } else {
                        serverSyncStatus.innerHTML = ''; // Clear any previous content
                        
                        // Keep broker info even if server sync data is missing
                        const mqttAddress = brokerInfo.address ? `${brokerInfo.address}:${brokerInfo.port || '1883'}` : '-';
                        const topics = brokerInfo.subscribedTopics && brokerInfo.subscribedTopics.length > 0 ? 
                            brokerInfo.subscribedTopics.join(', ') : '-';
                        
                        serverBrokerInfo.innerHTML = `
                            <div>MQTT: ${mqttAddress}</div>
                            <div>Last Value: -</div>
                            <div>Synched Values: -</div>
                            <div>Topics: ${topics}</div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error fetching sequence data:', error);
                    document.getElementById('serverSyncStatus').innerHTML = '';
                    
                    // Keep broker info even on error
                    const serverBrokerInfo = document.getElementById('serverBrokerInfo');
                    const mqttAddress = brokerInfo.address ? `${brokerInfo.address}:${brokerInfo.port || '1883'}` : '-';
                    const topics = brokerInfo.subscribedTopics && brokerInfo.subscribedTopics.length > 0 ? 
                        brokerInfo.subscribedTopics.join(', ') : '-';
                    
                    serverBrokerInfo.innerHTML = `
                        <div>MQTT: ${mqttAddress}</div>
                        <div>Last Value: -</div>
                        <div>Synched Values: -</div>
                        <div>Topics: ${topics}</div>
                    `;
                });
        }
        
        // Helper function to update broker info display
        function updateBrokerInfoDisplay() {
            const serverBrokerInfo = document.getElementById('serverBrokerInfo');
            
            // Always show the MQTT info with placeholders for values
            // Last Value and Synched Values will be updated by fetchSequenceData
            serverBrokerInfo.innerHTML = `
                <div>MQTT: ${brokerInfo.address ? `${brokerInfo.address}:${brokerInfo.port || '1883'}` : '-'}</div>
                <div>Last Value: -</div>
                <div>Synched Values: -</div>
                <div>Topics: ${brokerInfo.subscribedTopics && brokerInfo.subscribedTopics.length > 0 ? brokerInfo.subscribedTopics.join(', ') : '-'}</div>
            `;
        }
        
        // Update broker information
        socket.on('brokerInfo', (data) => {
            // Update server connection status based on broker connection
            const serverConnectionHeader = document.getElementById('serverConnectionHeader');
            if (data.connected) {
                serverConnectionHeader.textContent = 'Server Connected';
                serverConnectionHeader.style.color = 'var(--success-color)';
            }
            
            // Store broker information for display
            brokerInfo = {
                address: data.address || null,
                port: data.port || '1883',
                subscribedTopics: data.subscribedTopics || []
            };
            
            // Update the display
            updateBrokerInfoDisplay();
        });
        
        // Helper function to format date/time
        function formatDateTime(timestamp) {
            if (!timestamp || timestamp === 'Never') return 'Never';
            
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                year: '2-digit',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
        
        function updateClock() {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                month: 'long',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZoneName: 'short'
            });
            
            const parts = formatter.formatToParts(now);
            const date = parts.find(p => p.type === 'month').value + ' ' +
                        parts.find(p => p.type === 'day').value + ' ' +
                        parts.find(p => p.type === 'year').value;
            const time = parts.find(p => p.type === 'hour').value + ':' +
                        parts.find(p => p.type === 'minute').value + ':' +
                        parts.find(p => p.type === 'second').value;
            const timezone = parts.find(p => p.type === 'timeZoneName').value;
            
            const dateDisplay = document.getElementById('dateDisplay');
            const timeDisplay = document.getElementById('timeDisplay');
            const timezoneDisplay = document.getElementById('timezoneDisplay');
            
            if (dateDisplay && timeDisplay && timezoneDisplay) {
                dateDisplay.textContent = date + ', ';
                timeDisplay.textContent = time;
                timezoneDisplay.textContent = ' (' + timezone + ')';
            }
        }

        // Sensor management functions
        function renderSensors() {
            const container = document.getElementById('sensors-container');
            
            // Keep the add sensor card and remove everything else
            const addSensorCard = document.getElementById('add-sensor-card');
            container.innerHTML = '';
            container.appendChild(addSensorCard);
            
            if (sensors.length === 0) {
                container.appendChild(document.createElement('div')).className = 'empty-state';
                container.lastChild.textContent = 'No sensors configured yet. Add a sensor to get started.';
                return;
            }
            
            // Sort sensors by ID for consistent ordering
            sensors.sort((a, b) => a.id - b.id);
            
            sensors.forEach(sensor => {
                // Get sensor data if available
                const data = sensorData[sensor.address] || {};
                
                // Create sensor card
                const card = document.createElement('div');
                card.className = `sensor-card ${sensor.enabled ? '' : 'disabled'}`;
                card.dataset.id = sensor.id;
                card.dataset.address = sensor.address;
                
                // Parse type and address from sensor type field
                const [address, type] = sensor.address.includes('-') ? 
                    [sensor.address.split('-')[0], sensor.address.split('-')[1]] : 
                    [sensor.address, sensor.type];
                
                card.innerHTML = `
                    <div class="sensor-header">
                        <div class="sensor-title">${type} ${address}</div>
                        <div class="sensor-toggle">
                            <span>${sensor.enabled ? 'Enabled' : 'Disabled'}</span>
                            <label class="switch">
                                <input type="checkbox" class="toggle-sensor" ${sensor.enabled ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="sensor-data">
                        <div class="sensor-value">
                            <span>Temperature:</span>
                            <span class="temp-value" data-address="${sensor.address}">
                                ${data.temperature || 'Waiting...'}
                            </span>
                        </div>
                        <div class="sensor-value">
                            <span>Humidity:</span>
                            <span class="humidity-value" data-address="${sensor.address}">
                                ${data.humidity ? `${data.humidity.toFixed(1)}%` : 'Waiting...'}
                            </span>
                        </div>
                    </div>
                    <div class="sensor-actions">
                        <button class="delete-sensor">Remove</button>
                    </div>
                `;
                
                // Add event listeners
                const toggleBtn = card.querySelector('.toggle-sensor');
                if (toggleBtn) {
                    toggleBtn.addEventListener('change', function() {
                        toggleSensor(sensor.id, this.checked);
                    });
                }
                
                const deleteBtn = card.querySelector('.delete-sensor');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', function() {
                        if (confirm(`Are you sure you want to remove ${type} ${address}?`)) {
                            deleteSensor(sensor.id);
                        }
                    });
                }
                
                container.appendChild(card);
            });
        }
        
        function addSensor() {
            const select = document.getElementById('sensorTypeSelect');
            const sensorTypeValue = select.value;
            
            if (!sensorTypeValue) {
                alert('Please select a sensor type');
                return;
            }
            
            // Check if this sensor already exists
            const [address, type] = sensorTypeValue.split('-');
            const existing = sensors.find(s => s.address === address && s.type === type);
            
            if (existing) {
                alert(`A sensor with address ${address} is already configured`);
                return;
            }
            
            // Add the sensor via socket
            socket.emit('addSensor', {
                address,
                type,
                name: `${type} ${address}`
            });
            
            // Reset the select
            select.value = '';
        }
        
        function toggleSensor(id, enabled) {
            socket.emit('updateSensor', {
                id,
                enabled
            });
        }
        
        function deleteSensor(id) {
            socket.emit('deleteSensor', { id });
        }
        
        // Socket event handlers for sensors
        socket.on('sensorsUpdated', (data) => {
            sensors = data;
            renderSensors();
        });
        
        socket.on('sensorAdded', (sensor) => {
            // Add to local array if not exists
            if (!sensors.find(s => s.id === sensor.id)) {
                sensors.push(sensor);
            }
            renderSensors();
        });
        
        socket.on('sensorUpdated', (sensor) => {
            // Update in local array
            const index = sensors.findIndex(s => s.id === sensor.id);
            if (index !== -1) {
                sensors[index] = sensor;
            }
            renderSensors();
        });
        
        socket.on('sensorDeleted', (data) => {
            // Remove from local array
            sensors = sensors.filter(s => s.id !== data.id);
            renderSensors();
        });
        
        socket.on('sensorError', (data) => {
            alert(`Sensor error: ${data.message}`);
        });

        // Custom initialization for this page
        function customInit() {
            // Update clock every second
            setInterval(updateClock, 1000);
            updateClock(); // Initial update

            // Initialize broker info display to ensure fields are always visible
            updateBrokerInfoDisplay();
            
            // Fetch sequence data every second
            fetchSequenceData(); // Initial fetch
            setInterval(fetchSequenceData, 1000); // Update every second

            // Request fresh system information periodically to catch system changes
            setInterval(() => {
                socket.emit('getInitialState');
            }, 30000); // Every 30 seconds

            // Timezone update button
            const updateTimezoneButton = document.getElementById('updateTimezone');
            if (updateTimezoneButton) {
                updateTimezoneButton.addEventListener('click', () => {
                    const timezoneSelect = document.getElementById('timezoneSelect');
                    if (timezoneSelect) {
                        const timezone = timezoneSelect.value;
                        socket.emit('setTimezone', { timezone });
                    }
                });
            }
            
            // Request timezone
            socket.emit('getTimezone');
            
            // Setup "Add Sensor" button
            function setupAddSensorButton() {
                const addSensorButton = document.getElementById('addSensorButton');
                if (addSensorButton) {
                    // Remove any existing event listeners by cloning and replacing
                    const newButton = addSensorButton.cloneNode(true);
                    addSensorButton.parentNode.replaceChild(newButton, addSensorButton);
                    newButton.addEventListener('click', addSensor);
                }
            }
            
            // Setup button initially
            setupAddSensorButton();
            
            // Re-setup button after sensors are rendered
            const originalRenderSensors = renderSensors;
            renderSensors = function() {
                originalRenderSensors();
                setupAddSensorButton();
            };
            
            // Initial load of sensors
            socket.emit('getSensors');
        }

        // Handle timezone updates
        socket.on('timezoneUpdate', (data) => {
            const { timezone } = data;
            const timezoneSelect = document.getElementById('timezoneSelect');
            if (timezoneSelect) {
                timezoneSelect.value = timezone;
            }
            currentTimezone = timezone;
            updateClock();
        });

        socket.on('sensorData', (data) => {
            // Update system information
            document.getElementById('piUptime').textContent = data.system.piUptime;
            document.getElementById('serverUptime').textContent = data.system.serverUptime;
            document.getElementById('ipAddress').textContent = data.system.ipAddress;
            document.getElementById('macAddress').textContent = data.system.macAddress;
            document.getElementById('hostname').textContent = data.system.hostname;
            document.getElementById('cpuTemp').textContent = data.system.cpuTemp;
            
            // Update header with hostname and IP address
            const hostname = data.system.hostname || '';
            const ipAddress = data.system.ipAddress || '';
            // Extract the last part of the hostname and the last octet of the IP
            const hostnameShort = hostname.split('-').pop() || '';
            const ipOctet = ipAddress.split('.').pop() || '';
            if (hostnameShort && ipOctet) {
                document.getElementById('nodeHeader').textContent = `${hostnameShort}.${ipOctet}`;
                document.getElementById('nodeIdDisplay').textContent = hostnameShort;
            }
            
            // Update internet status with color coding
            const internetStatusElement = document.getElementById('internetStatus');
            if (internetStatusElement) {
                internetStatusElement.textContent = data.system.internetStatus;
                internetStatusElement.style.color = data.system.internetConnected ? 
                    'var(--success-color)' : 'var(--error-color)';
            }
            
            // Update clock status
            const clockStatusElement = document.getElementById('clockStatus');
            if (clockStatusElement) {
                clockStatusElement.textContent = data.system.timeSinceSync;
            }
            
            // Update system timezone
            const systemTimezoneElement = document.getElementById('systemTimezone');
            if (systemTimezoneElement && data.system.systemTimezone) {
                systemTimezoneElement.textContent = formatTimezoneDisplay(data.system.systemTimezone);
            }
            
            // Update database timezone
            const databaseTimezoneElement = document.getElementById('databaseTimezone');
            if (databaseTimezoneElement && data.databaseTimezone) {
                databaseTimezoneElement.textContent = formatTimezoneDisplay(data.databaseTimezone);
            }

            // Update sensor data cache
            if (data.sensor1) {
                sensorData['0x38'] = {
                    address: data.sensor1.address,
                    temperature: data.sensor1.temperature,
                    humidity: data.sensor1.humidity
                };
                
                // Update UI for this sensor if it exists
                const tempElements = document.querySelectorAll('.temp-value[data-address="0x38"]');
                const humidityElements = document.querySelectorAll('.humidity-value[data-address="0x38"]');
                
                tempElements.forEach(el => {
                    el.textContent = data.sensor1.temperature;
                });
                
                humidityElements.forEach(el => {
                    el.textContent = `${data.sensor1.humidity.toFixed(1)}%`;
                });
            }

            if (data.sensor2) {
                sensorData['0x39'] = {
                    address: data.sensor2.address,
                    temperature: data.sensor2.temperature,
                    humidity: data.sensor2.humidity
                };
                
                // Update UI for this sensor if it exists
                const tempElements = document.querySelectorAll('.temp-value[data-address="0x39"]');
                const humidityElements = document.querySelectorAll('.humidity-value[data-address="0x39"]');
                
                tempElements.forEach(el => {
                    el.textContent = data.sensor2.temperature;
                });
                
                humidityElements.forEach(el => {
                    el.textContent = `${data.sensor2.humidity.toFixed(1)}%`;
                });
            }
        });

        socket.on('systemState', function(data) {
            // Update modes
            document.getElementById('mode-auto').textContent = data.modes.automatic ? '1' : '0';
            document.getElementById('mode-emergency').textContent = data.modes.emergency ? '1' : '0';

            // Update manual PWM
            Object.entries(data.manualPwm).forEach(([pin, state]) => {
                const element = document.getElementById(`manual-${pin}`);
                if (element) {
                    element.textContent = `{${state.value}, ${state.enabled}}`;
                }
            });

            // Update automatic PWM
            Object.entries(data.autoPwm).forEach(([pin, value]) => {
                const element = document.getElementById(`auto-${pin}`);
                if (element) {
                    element.textContent = value;
                }
            });

            // Update schedule
            Object.entries(data.schedule).forEach(([pin, events]) => {
                const element = document.getElementById(`schedule-${pin}`);
                if (element) {
                    if (events.length === 0) {
                        element.textContent = '-';
                    } else {
                        element.innerHTML = events.map(event => 
                            `<div class="schedule-event ${event.enabled ? 'enabled' : 'disabled'}">
                                {"${event.time}", ${event.value}, ${event.enabled}}
                            </div>`
                        ).join('');
                    }
                }
            });
        });

        // Also update on state changes
        socket.on('stateUpdate', function() {
            socket.emit('getSystemState');
        });

        socket.on('modeUpdate', function() {
            socket.emit('getSystemState');
        });

        // Initialize the application
        initializeApp(socket, customInit);
    </script>
</body>
</html> 