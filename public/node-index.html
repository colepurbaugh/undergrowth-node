<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Undergrowth Node</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="mask-icon" href="/assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="/assets/js/core.js"></script>
</head>
<body class="normal-state" style="background-image: url('/assets/backgrounds/undergrowth_logo.png') !important; background-repeat: no-repeat !important; background-position: top center !important; background-size: 90vh auto !important; background-attachment: fixed !important;">
    <div class="container">
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]" id="nodeHeader">System Information</h2>
            <button id="emergencyButton" class="emergency-button">Emergency Stop</button>
        </div>
        <div class="timezone-section">
            <div class="clock-display">
                <span id="dateDisplay"></span>
                <span id="timeDisplay"></span>
                <span id="timezoneDisplay"></span>
            </div>
            <div class="timezone-controls">
                <select id="timezoneSelect">
                    <!-- US Timezones -->
                    <option value="America/New_York">ET</option>
                    <option value="America/Chicago">CT</option>
                    <option value="America/Denver">MT</option>
                    <option value="America/Los_Angeles">PT</option>
                    <option value="America/Anchorage">AKT</option>
                    <option value="Pacific/Honolulu">HT</option>
                    <!-- UTC Offsets -->
                    <option value="UTC">UTC</option>
                    <option value="UTC+1">UTC+1</option>
                    <option value="UTC+2">UTC+2</option>
                    <option value="UTC+3">UTC+3</option>
                    <option value="UTC+4">UTC+4</option>
                    <option value="UTC+5">UTC+5</option>
                    <option value="UTC+6">UTC+6</option>
                    <option value="UTC+7">UTC+7</option>
                    <option value="UTC+8">UTC+8</option>
                    <option value="UTC+9">UTC+9</option>
                    <option value="UTC+10">UTC+10</option>
                    <option value="UTC+11">UTC+11</option>
                    <option value="UTC+12">UTC+12</option>
                    <option value="UTC-1">UTC-1</option>
                    <option value="UTC-2">UTC-2</option>
                    <option value="UTC-3">UTC-3</option>
                    <option value="UTC-4">UTC-4</option>
                    <option value="UTC-5">UTC-5</option>
                    <option value="UTC-6">UTC-6</option>
                    <option value="UTC-7">UTC-7</option>
                    <option value="UTC-8">UTC-8</option>
                    <option value="UTC-9">UTC-9</option>
                    <option value="UTC-10">UTC-10</option>
                    <option value="UTC-11">UTC-11</option>
                    <option value="UTC-12">UTC-12</option>
                </select>
                <button id="updateTimezone">Update Timezone</button>
            </div>
        </div>
    
        <div class="nav-buttons">
            <a href="/pwm" class="nav-button pwm">PWM & Schedule</a>
            <a href="/graph" class="nav-button graph">Graph</a>
        </div>
        <div class="info-section">
            <div class="info-item">
                <div class="info-label">Pi Uptime:</div>
                <div class="info-value" id="piUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Server Uptime:</div>
                <div class="info-value" id="serverUptime">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">IP Address:</div>
                <div class="info-value" id="ipAddress">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">MAC Address:</div>
                <div class="info-value" id="macAddress">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Hostname:</div>
                <div class="info-value" id="hostname">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">CPU Temperature:</div>
                <div class="info-value" id="cpuTemp">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Internet Status:</div>
                <div class="info-value" id="internetStatus">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">System Timezone:</div>
                <div class="info-value" id="systemTimezone">Loading...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Database Timezone:</div>
                <div class="info-value" id="databaseTimezone">Loading...</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Sensors</h2>
        <div class="info-section" id="sensors-container">
            <!-- Fixed sensor cards replace the complex UI -->
            <div class="sensor-card" data-id="1" data-address="0x38">
                <div class="sensor-data">
                    <div class="sensor-readings">
                        <div class="sensor-info">Address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sensor-address">0x38</span></div>
                        <div class="sensor-info">Temperature:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sensor-temp" data-address="0x38">--</span></div>
                        <div class="sensor-info">Humidity:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sensor-humidity" data-address="0x38">--</span></div>
                    </div>
                </div>
            </div>
            
            <div class="sensor-card" data-id="2" data-address="0x39">
                <div class="sensor-data">
                    <div class="sensor-readings">
                        <div class="sensor-info">Address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sensor-address">0x39</span></div>
                        <div class="sensor-info">Temperature:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sensor-temp" data-address="0x39">--</span></div>
                        <div class="sensor-info">Humidity:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sensor-humidity" data-address="0x39">--</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- New MQTT/Local Info Cards -->
    <div class="container">
        <h2>MQTT Status</h2>
        <div class="info-section">
            <div class="info-item">
                <div class="info-label">MQTT:</div>
                <div class="info-value" id="mqttStatusValue">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">Last Message:</div>
                <div class="info-value" id="lastMessageValue">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">Local Values:</div>
                <div class="info-value" id="localValuesValue">--</div>
            </div>
        </div>
    </div>

    <style>
        /* Sensor Card Updates */
        .sensor-readings {
            font-family: monospace;
            font-size: 1.1rem;
            margin: 10px 0;
            color: var(--text-primary);
            text-align: center;
        }

        .sensor-info {
            display: block;
            padding: 5px 15px;
            font-family: monospace;
            font-size: 1.1rem;
            text-align: left;
        }

        .sensor-info::before {
            display: none;
        }

        .sensor-info {
            position: static;
        }

        .sensor-info span {
            font-weight: bold;
            color: var(--text-secondary);
            position: static;
            float: right;
        }

        .sensor-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }

        .sensor-stat {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
        }

        /* Sync Section */
        .sync-info-item {
            width: 100%;
            padding: 15px;
            background-color: #333;
            opacity: 0.8;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
        }

        .sync-node-info, .sync-server-info, .sync-timestamp {
            font-family: monospace;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .sync-counts {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
            margin: 10px 0;
        }

        .sync-progress-container {
            margin-top: 10px;
        }

        .sync-progress-bar {
            height: 20px;
            background-color: #222;
            border-radius: 10px;
            overflow: hidden;
        }

        .sync-progress-fill {
            height: 100%;
            background-color: var(--success-color);
        }

        .sync-percentage {
            text-align: center;
            margin-top: 5px;
            font-family: monospace;
        }
        
        .sync-connection-status {
            margin-top: 10px;
            font-style: italic;
            text-align: center;
        }

        /* Database Info Section */
        .database-info-item {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            background-color: #333;
            opacity: 0.8;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            margin-bottom: 10px;
        }

        .database-header {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .database-content {
            margin-top: 10px;
        }

        .database-section {
            margin-bottom: 15px;
        }

        .section-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .command-box {
            background-color: #222;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .command-box code {
            font-family: monospace;
            color: var(--text-primary);
            white-space: nowrap;
        }
    </style>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentTimezone = 'America/Los_Angeles';
        let brokerInfo = {
            connected: false,
            address: null,
            port: "1883",
            subscribedTopics: [],
            lastMessage: null
        };
        let sensorData = {}; // Store the latest sensor readings
        
        // Define custom handler for initial state data
        function onInitialState(data) {
            console.log('onInitialState', data); // Debug log
            // Update system information and other data
            if (data.system) {
                const piUptime = document.getElementById('piUptime');
                if (piUptime) piUptime.textContent = data.system.piUptime;
                
                const serverUptime = document.getElementById('serverUptime');
                if (serverUptime) serverUptime.textContent = data.system.serverUptime;
                
                const ipAddress = document.getElementById('ipAddress');
                if (ipAddress) ipAddress.textContent = data.system.ipAddress;
                
                const macAddress = document.getElementById('macAddress');
                if (macAddress) macAddress.textContent = data.system.macAddress;
                
                const hostname = document.getElementById('hostname');
                if (hostname) hostname.textContent = data.system.hostname;
                
                const cpuTemp = document.getElementById('cpuTemp');
                if (cpuTemp) cpuTemp.textContent = data.system.cpuTemp;
                
                // Update header with hostname and IP address
                const hostname_val = data.system.hostname || '';
                const ipAddress_val = data.system.ipAddress || '';
                // Extract the last part of the hostname and the last octet of the IP
                const hostnameShort = hostname_val.split('-').pop() || '';
                const ipOctet = ipAddress_val.split('.').pop() || '';
                
                const nodeHeader = document.getElementById('nodeHeader');
                if (hostnameShort && ipOctet && nodeHeader) {
                    nodeHeader.textContent = `${hostnameShort}.${ipOctet}`;
                }
                
                const nodeIdDisplay = document.getElementById('nodeIdDisplay');
                if (hostnameShort && nodeIdDisplay) {
                    nodeIdDisplay.textContent = hostnameShort;
                }
                
                // Update internet status with color coding
                const internetStatusElement = document.getElementById('internetStatus');
                if (internetStatusElement) {
                    internetStatusElement.textContent = data.system.internetStatus;
                    internetStatusElement.style.color = data.system.internetConnected ? 
                        'var(--success-color)' : 'var(--error-color)';
                }
                
                // Update system timezone
                const systemTimezoneElement = document.getElementById('systemTimezone');
                if (systemTimezoneElement && data.system.systemTimezone) {
                    systemTimezoneElement.textContent = formatTimezoneDisplay(data.system.systemTimezone);
                }
            }
            
            // Update database timezone
            const databaseTimezoneElement = document.getElementById('databaseTimezone');
            if (databaseTimezoneElement && data.databaseTimezone) {
                databaseTimezoneElement.textContent = formatTimezoneDisplay(data.databaseTimezone);
            }

            // Update sensor data cache and display for all sensors by address
            for (const [address, sensorData] of Object.entries(data)) {
                // Skip non-sensor keys (system, databaseTimezone, etc.)
                if (address === 'system' || address === 'databaseTimezone') continue;
                
                // Update our data cache
                sensorData[address] = sensorData;
                
                // Update the display
                updateSensorDisplay(address, sensorData);
            }
            
            // After receiving initial state, request configured sensors
            socket.emit('getSensors');
        }
        
        // Helper function to format timezone for display
        function formatTimezoneDisplay(timezone) {
            if (!timezone) return 'Unknown';
            return timezone;
        }
        
        // Function to update sensor display with latest data
        function updateSensorDisplay(address, data) {
            const tempElement = document.querySelector(`.sensor-temp[data-address="${address}"]`);
            const humidityElement = document.querySelector(`.sensor-humidity[data-address="${address}"]`);
            
            if (tempElement && data.temperature) {
                tempElement.textContent = data.temperature;
            }
            
            if (humidityElement && data.humidity) {
                humidityElement.textContent = `${data.humidity.toFixed(1)}%`;
            }
        }
        
        // Function to fetch and update sequence data
        function fetchSequenceData() {
            fetch('/api/sequence-info')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.nodeSequence && data.nodeSequence.count !== undefined) {
                        updateSystemStatusCards(data);
                    }
                })
                .catch(error => {
                    // Silently handle errors to prevent "--" from showing
                });
        }
        
        // Helper function to update broker info display
        function updateBrokerInfoDisplay() {
            console.log('Updating broker info display with:', brokerInfo);
            // Only update new MQTT status card
            const mqttStatusElem = document.getElementById('mqttStatusValue');
            if (mqttStatusElem) {
                if (brokerInfo && brokerInfo.address) {
                    const statusColor = brokerInfo.connected ? 'var(--success-color)' : 'var(--error-color)';
                    mqttStatusElem.textContent = `${brokerInfo.address}:${brokerInfo.port || '1883'}`;
                    mqttStatusElem.style.color = statusColor;
                } else {
                    mqttStatusElem.textContent = 'Not connected';
                    mqttStatusElem.style.color = 'var(--error-color)';
                }
            }
        }
        
        // Helper to format time ago for last message
        function formatTimeAgo(timestamp) {
            if (!timestamp) return '--';
            const now = Date.now();
            const then = new Date(timestamp).getTime();
            let diff = Math.floor((now - then) / 1000); // seconds
            if (diff < 60) return `${diff} seconds ago`;
            let minutes = Math.floor(diff / 60);
            if (minutes < 60) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
            let hours = Math.floor(minutes / 60);
            minutes = minutes % 60;
            if (hours < 24) return `${hours} hour${hours !== 1 ? 's' : ''}${minutes > 0 ? ' ' + minutes + ' minute' + (minutes !== 1 ? 's' : '') : ''} ago`;
            let days = Math.floor(hours / 24);
            hours = hours % 24;
            if (days < 365) return `${days} day${days !== 1 ? 's' : ''}${hours > 0 ? ' ' + hours + ' hour' + (hours !== 1 ? 's' : '') : ''} ago`;
            let years = Math.floor(days / 365);
            days = days % 365;
            return `${years} year${years !== 1 ? 's' : ''}${days > 0 ? ' ' + days + ' day' + (days !== 1 ? 's' : '') : ''} ago`;
        }

        // Update new info cards when broker info or sequence info is available
        function updateSystemStatusCards(sequenceData) {
            // Last Message
            const lastMessageElem = document.getElementById('lastMessageValue');
            if (lastMessageElem && brokerInfo && brokerInfo.lastMessage) {
                lastMessageElem.textContent = formatTimeAgo(brokerInfo.lastMessage);
            }
            
            // Local Values
            const localValuesElem = document.getElementById('localValuesValue');
            if (localValuesElem && sequenceData && sequenceData.nodeSequence) {
                const localValues = sequenceData.nodeSequence.count || 0;
                localValuesElem.textContent = localValues.toLocaleString();
            }
        }

        // Update broker information
        socket.on('brokerInfo', (data) => {
            console.log('Received broker info:', data);
            
            // Store broker information for display
            brokerInfo = {
                connected: data.connected === true, // Ensure this is a boolean
                address: data.address || null,
                port: data.port || '1883',
                subscribedTopics: data.subscribedTopics || [],
                lastMessage: data.lastMessage || null
            };
            
            // Update the display immediately
            updateBrokerInfoDisplay();
            
            // Also update system status cards (last message)
            updateSystemStatusCards();
        });
        
        // Helper function to format date/time
        function formatDateTime(timestamp) {
            if (!timestamp || timestamp === 'Never') return 'Never';
            
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                year: '2-digit',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
        
        function updateClock() {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                month: 'long',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZoneName: 'short'
            });
            
            const parts = formatter.formatToParts(now);
            const date = parts.find(p => p.type === 'month').value + ' ' +
                        parts.find(p => p.type === 'day').value + ' ' +
                        parts.find(p => p.type === 'year').value;
            const time = parts.find(p => p.type === 'hour').value + ':' +
                        parts.find(p => p.type === 'minute').value + ':' +
                        parts.find(p => p.type === 'second').value;
            const timezone = parts.find(p => p.type === 'timeZoneName').value;
            
            const dateDisplay = document.getElementById('dateDisplay');
            const timeDisplay = document.getElementById('timeDisplay');
            const timezoneDisplay = document.getElementById('timezoneDisplay');
            
            if (dateDisplay && timeDisplay && timezoneDisplay) {
                dateDisplay.textContent = date + ', ';
                timeDisplay.textContent = time;
                timezoneDisplay.textContent = ' (' + timezone + ')';
            }
        }

        // Custom initialization for this page
        function customInit() {
            // Update clock every second
            setInterval(updateClock, 1000);
            updateClock(); // Initial update

            // Initialize broker info display to ensure fields are always visible
            updateBrokerInfoDisplay();
            
            // Fetch sequence data every second
            fetchSequenceData(); // Initial fetch
            setInterval(fetchSequenceData, 1000); // Update every second

            // Request fresh system information periodically to catch system changes
            setInterval(() => {
                socket.emit('getInitialState');
            }, 30000); // Every 30 seconds

            // Timezone update button
            const updateTimezoneButton = document.getElementById('updateTimezone');
            if (updateTimezoneButton) {
                updateTimezoneButton.addEventListener('click', () => {
                    const timezoneSelect = document.getElementById('timezoneSelect');
                    if (timezoneSelect) {
                        const timezone = timezoneSelect.value;
                        socket.emit('setTimezone', { timezone });
                    }
                });
            }
            
            // Request timezone
            socket.emit('getTimezone');
            
            // Request initial state for sensor data
            socket.emit('getInitialState');
        }

        // Handle timezone updates
        socket.on('timezoneUpdate', (data) => {
            const { timezone } = data;
            const timezoneSelect = document.getElementById('timezoneSelect');
            if (timezoneSelect) {
                timezoneSelect.value = timezone;
            }
            currentTimezone = timezone;
            updateClock();
        });

        socket.on('sensorData', (data) => {
            console.log('sensorData received:', data); // Debug log
            // Update system information
            const piUptime = document.getElementById('piUptime');
            if (piUptime) piUptime.textContent = data.system.piUptime;
            
            const serverUptime = document.getElementById('serverUptime');
            if (serverUptime) serverUptime.textContent = data.system.serverUptime;
            
            const ipAddress = document.getElementById('ipAddress');
            if (ipAddress) ipAddress.textContent = data.system.ipAddress;
            
            const macAddress = document.getElementById('macAddress');
            if (macAddress) macAddress.textContent = data.system.macAddress;
            
            const hostname = document.getElementById('hostname');
            if (hostname) hostname.textContent = data.system.hostname;
            
            const cpuTemp = document.getElementById('cpuTemp');
            if (cpuTemp) cpuTemp.textContent = data.system.cpuTemp;
            
            // Update header with hostname and IP address
            const hostname_val = data.system.hostname || '';
            const ipAddress_val = data.system.ipAddress || '';
            // Extract the last part of the hostname and the last octet of the IP
            const hostnameShort = hostname_val.split('-').pop() || '';
            const ipOctet = ipAddress_val.split('.').pop() || '';
            
            const nodeHeader = document.getElementById('nodeHeader');
            if (hostnameShort && ipOctet && nodeHeader) {
                nodeHeader.textContent = `${hostnameShort}.${ipOctet}`;
            }
            
            const nodeIdDisplay = document.getElementById('nodeIdDisplay');
            if (nodeIdDisplay) {
                nodeIdDisplay.textContent = hostnameShort;
            }
            
            // Update internet status with color coding
            const internetStatusElement = document.getElementById('internetStatus');
            if (internetStatusElement) {
                internetStatusElement.textContent = data.system.internetStatus;
                internetStatusElement.style.color = data.system.internetConnected ? 
                    'var(--success-color)' : 'var(--error-color)';
            }
            
            // Update system timezone
            const systemTimezoneElement = document.getElementById('systemTimezone');
            if (systemTimezoneElement && data.system.systemTimezone) {
                systemTimezoneElement.textContent = formatTimezoneDisplay(data.system.systemTimezone);
            }
            
            // Update database timezone
            const databaseTimezoneElement = document.getElementById('databaseTimezone');
            if (databaseTimezoneElement && data.databaseTimezone) {
                databaseTimezoneElement.textContent = formatTimezoneDisplay(data.databaseTimezone);
            }

            // Update local values if present in the data
            const localValuesElem = document.getElementById('localValuesValue');
            if (localValuesElem && data.localValues !== undefined) {
                localValuesElem.textContent = data.localValues.toLocaleString();
            }

            // Update sensor data cache and display for all sensors by address
            for (const [address, sensorData] of Object.entries(data)) {
                // Skip non-sensor keys (system, databaseTimezone, etc.)
                if (address === 'system' || address === 'databaseTimezone' || address === 'localValues') continue;
                
                // Update the display
                updateSensorDisplay(address, sensorData);
            }
        });

        socket.on('systemState', function(data) {
            // Update modes if elements exist
            const modeAuto = document.getElementById('mode-auto');
            if (modeAuto) modeAuto.textContent = data.modes.automatic ? '1' : '0';
            
            const modeEmergency = document.getElementById('mode-emergency');
            if (modeEmergency) modeEmergency.textContent = data.modes.emergency ? '1' : '0';

            // Update manual PWM if elements exist
            if (data.manualPwm) {
                Object.entries(data.manualPwm).forEach(([pin, state]) => {
                    const element = document.getElementById(`manual-${pin}`);
                    if (element) {
                        element.textContent = `{${state.value}, ${state.enabled}}`;
                    }
                });
            }

            // Update automatic PWM if elements exist
            if (data.autoPwm) {
                Object.entries(data.autoPwm).forEach(([pin, value]) => {
                    const element = document.getElementById(`auto-${pin}`);
                    if (element) {
                        element.textContent = value;
                    }
                });
            }

            // Update schedule if elements exist
            if (data.schedule) {
                Object.entries(data.schedule).forEach(([pin, events]) => {
                    const element = document.getElementById(`schedule-${pin}`);
                    if (element) {
                        if (events.length === 0) {
                            element.textContent = '-';
                        } else {
                            element.innerHTML = events.map(event => 
                                `<div class="schedule-event ${event.enabled ? 'enabled' : 'disabled'}">
                                    {"${event.time}", ${event.value}, ${event.enabled}}
                                </div>`
                            ).join('');
                        }
                    }
                });
            }
        });

        // Also update on state changes
        socket.on('stateUpdate', function() {
            socket.emit('getSystemState');
        });

        socket.on('modeUpdate', function() {
            socket.emit('getSystemState');
        });

        // Initialize the application
        initializeApp(socket, customInit);
    </script>
</body>
</html> 