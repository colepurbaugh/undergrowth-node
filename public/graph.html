<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sensor Data Graphs</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <!-- First load Chart.js without adapter -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- Then load Luxon and the adapter separately -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.3.0/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <!-- Add annotations plugin for time reference lines only -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="/assets/js/core.js"></script>
    <style>
        .sensor-controls-row {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            margin-bottom: 2rem; /* Add more space before Temperature chart */
        }
        
        .sensor-column {
            flex: 1;
            min-width: 0; /* Allows flex items to shrink below their content size */
            padding: 15px 20px; /* Reduced vertical padding from 20px to 15px */
            background-color: #333; /* Match other divs */
            opacity: 0.8; /* Match other divs */
            border: 1px solid var(--border-color);
            border-radius: 0.25rem; /* Match other divs */
            text-align: left; /* Left align content for better horizontal flow */
            overflow: hidden; /* Prevent content from overflowing */
            box-sizing: border-box; /* Include padding in width calculations */
        }
        
        .column-title {
            margin: 0 0 20px 0; /* Reduced bottom margin from 15px to 10px for Sensors column */
            color: #e8e6e3;
            font-size: 18px;
            font-weight: bold;
            text-align: left; /* Left align titles to match content */
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 6px; /* Reduced from 8px to 6px for Sensors column */
        }
        
        .sensor-selection-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
            align-items: center;
            overflow: hidden;
            margin-bottom: 12px;
        }
        
        .sensor-button-container {
            display: flex;
            gap: 8px;
            justify-content: flex-start;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .sensor-checkbox-wrapper {
            display: inline-block;
            vertical-align: middle;
            padding: 0;
            margin: 0;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.25rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            white-space: nowrap;
            height: 32px;
            box-sizing: border-box;
            line-height: 32px;
        }
        
        .sensor-checkbox-wrapper:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Additional specificity to override any inherited styles */
        .sensor-column .sensor-selection-container .sensor-checkbox-wrapper {
            justify-content: flex-start !important;
            text-align: left !important;
            display: flex !important;
            align-items: center !important;
        }
        
        .sensor-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--success-color);
            margin: 0 4px 0 4px;
            vertical-align: middle;
        }
        
        .sensor-label {
            color: #e8e6e3;
            font-size: 1.2rem;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            text-align: left;
            margin: 0 4px 0 0;
            line-height: 1;
            white-space: nowrap;
            vertical-align: middle;
        }
        
        .sensor-label:hover {
            color: #fff;
        }
        

        
        .sensor-button {
            padding: 0 12px;
            background-color: var(--inactive-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 500;
            transition: background-color 0.2s;
            min-width: 100px;
            height: 32px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .sensor-button:hover {
            background-color: var(--active-color);
        }
        
        .loading-message, .error-message, .empty-state {
            color: #e8e6e3;
            font-size: 14px;
            font-style: italic;
            text-align: center;
            padding: 20px;
            opacity: 0.7;
        }
        
        .error-message {
            color: #ff6b6b;
        }
        
        .color-range-controls {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.1);
        }
        
        .color-range-title {
            margin: 0 0 12px 0;
            color: #e8e6e3;
            font-size: 16px;
            font-weight: bold;
        }
        
        .color-range-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            flex-direction: column;
            align-items: flex-end; /* Right-justify all elements in color-range-group */
            width: fit-content; /* Auto-shrink to content width */
            margin: 0 auto; /* Center the group within sensor-column */
        }
        
        .color-input-group {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the entire row */
            margin-bottom: 4px; /* Reduced from 6px to 4px */
            height: 32px;
        }
        
        .color-controls-container {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: flex-end; /* Right-justify the form controls */
        }
        
        .color-input-group.mid-row {
            position: relative;
        }
        
        .color-picker-container {
            position: relative;
            display: inline-block;
        }
        
        .color-picker {
            width: 32px;
            height: 32px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
            vertical-align: middle;
        }
        
        .color-hex {
            width: 100px;
            padding: 0 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            color: #333;
            font-size: 1.2rem;
            font-family: monospace;
            font-weight: 500;
            height: 32px;
            box-sizing: border-box;
            vertical-align: middle;
        }
        
        .mid-checkbox {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: var(--success-color);
            background-color: #333;
            border: 1px solid #ccc;
            border-radius: 2px;
            z-index: 1;
        }
        
        .mid-checkbox:checked {
            background-color: var(--success-color);
        }
        
        .color-input-group label {
            color: #e8e6e3;
            font-size: 1.2rem;
            font-weight: 500;
            min-width: 70px;
            text-align: center; /* Center labels in all columns */
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .range-input {
            width: 70px;
            padding: 0 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            color: #333;
            font-size: 1.2rem;
            font-weight: 500;
            height: 32px;
            box-sizing: border-box;
            vertical-align: middle;
        }
        
        #updateColorsButton {
            background-color: var(--success-color);
        }
        
        #updateColorsButton:hover {
            background-color: #2d6c30;
        }
        
        /* Time Navigation Styles */
        .time-navigation {
            background-color: #333;
            opacity: 0.8;
            padding: 1rem;
            border-radius: 0.25rem;
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            min-height: 120px;
        }
        
        .time-control-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .time-control-section.left {
            flex: 1;
            align-items: flex-start;
            text-align: left;
        }
        
        .time-control-section.center {
            flex: 1;
            align-items: center;
            text-align: center;
            justify-content: center;
        }
        
        .time-control-section.right {
            flex: 1;
            align-items: flex-end;
            text-align: right;
        }
        
        .range-info {
            margin-bottom: 1rem;
        }
        
        .range-info span {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        
        .time-display {
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            min-height: 20px;
        }
        
        .time-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .time-info span:first-child {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        
        .time-info span:last-child {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .nav-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .points-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: center;
        }
        
        .control-label {
            color: #e8e6e3;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .time-details {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .time-detail {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .time-label {
            font-weight: bold;
            color: var(--text-secondary);
            min-width: 40px;
        }
        
        .time-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .time-control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: inherit;
        }
        
        .time-control-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: bold;
        }
        
        .time-buttons {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }
        
        .time-btn {
            padding: 0.25rem 0.5rem;
            background-color: var(--inactive-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.8rem;
            transition: background-color 0.2s;
            min-width: 50px;
        }
        
        .time-btn:hover:not(:disabled) {
            background-color: var(--active-color);
        }
        
        .time-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .nav-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .nav-btn {
            padding: 0.5rem 1rem;
            background-color: var(--inactive-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.9rem;
            transition: background-color 0.2s, opacity 0.2s;
        }
        
        .nav-btn:hover:not(:disabled) {
            background-color: var(--active-color);
        }
        
        .nav-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .go-live-btn {
            padding: 0.25rem 0.75rem;
            background-color: var(--success-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.2s;
            white-space: nowrap;
        }
        
        .go-live-btn:hover {
            background-color: #2d6c30;
        }
        
        .go-live-btn:disabled {
            background-color: var(--inactive-color);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        @media (max-width: 768px) {
            .sensor-controls-row {
                flex-direction: column;
                gap: 15px;
            }
            
            .sensor-column {
                text-align: center !important;
                padding: 15px;
            }
            
            .column-title {
                text-align: center !important;
                font-size: 16px;
            }
            
            .sensor-selection-container {
                justify-content: center !important;
                gap: 4px !important;
                flex-wrap: wrap !important;
                margin-bottom: 8px !important;
            }
            
            .sensor-button-container {
                justify-content: center !important;
                gap: 6px !important;
                flex-wrap: wrap !important;
            }
            
            .sensor-checkbox-wrapper {
                min-width: auto !important;
                padding: 2px 4px !important;
                height: 28px !important;
                gap: 3px !important;
            }
            
            .sensor-label {
                font-size: 12px !important;
            }
            
            .sensor-button {
                min-width: 80px !important;
                height: 28px !important;
                font-size: 12px !important;
                padding: 4px 8px !important;
            }
            
            .color-range-group {
                align-items: center !important;
            }
            
            .color-input-group {
                justify-content: center !important;
                min-width: auto;
            }
            
            .color-input-group label {
                text-align: center !important;
                min-width: 60px;
            }
            
            .time-navigation {
                flex-direction: column;
                text-align: center;
                align-items: center;
            }
            
            .time-control-section {
                width: 100%;
                align-items: center !important;
                text-align: center !important;
            }
            
            .nav-controls {
                justify-content: center;
                flex-direction: column;
            }
            
            .time-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body class="normal-state" style="background-image: url('/assets/backgrounds/undergrowth_logo.png') !important; background-repeat: no-repeat !important; background-position: top center !important; background-size: 90vh auto !important; background-attachment: fixed !important;">
    <div class="container">
        <div class="header">
            <h1 class="title">Node Sensor Graphs</h1>
            <div class="header-right">
                <div id="currentTime" class="time-display"></div>
                <button id="emergencyButton" class="emergency-button">Emergency Stop</button>
            </div>
        </div>
        
        <!-- Sensor Selection -->
        <div class="sensor-controls-row">
            <!-- Column 1: Sensor Selection -->
            <div class="sensor-column">
                <h4 class="column-title">Sensors</h4>
                <div class="sensor-selection-container" id="sensorSelectionContainer">
                    <!-- Sensor checkboxes will be populated here -->
                    <div class="loading-message">Loading sensors...</div>
                </div>
                <div class="sensor-button-container">
                    <button id="averageSensors" class="sensor-button">Show Average</button>
                    <button id="updateColorsButton" class="sensor-button">Update Colors</button>
                </div>
            </div>
            
            <!-- Column 2: Temperature Color Range Controls -->
            <div class="sensor-column">
                <h4 class="column-title">Temperature Colors</h4>
                <div class="color-range-group">
                    <div class="color-input-group">
                        <label for="tempHighValue">High (째F):</label>
                        <div class="color-controls-container">
                            <input type="number" id="tempHighValue" value="85" min="0" max="120" class="range-input">
                            <div class="color-picker-container">
                                <input type="color" id="tempHighColor" value="#ff0000" class="color-picker">
                            </div>
                            <input type="text" id="tempHighColorHex" value="#ff0000" class="color-hex" maxlength="7">
                        </div>
                    </div>
                    <div class="color-input-group mid-row">
                        <label for="tempMidValue">Mid (째F):</label>
                        <div class="color-controls-container">
                            <input type="number" id="tempMidValue" value="77" min="0" max="120" class="range-input">
                            <div class="color-picker-container">
                                <input type="color" id="tempMidColor" value="#00ff00" class="color-picker">
                                <input type="checkbox" id="tempUseMid" class="mid-checkbox" title="Enable mid-point color">
                            </div>
                            <input type="text" id="tempMidColorHex" value="#00ff00" class="color-hex" maxlength="7">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label for="tempLowValue">Low (째F):</label>
                        <div class="color-controls-container">
                            <input type="number" id="tempLowValue" value="70" min="0" max="120" class="range-input">
                            <div class="color-picker-container">
                                <input type="color" id="tempLowColor" value="#0064ff" class="color-picker">
                            </div>
                            <input type="text" id="tempLowColorHex" value="#0064ff" class="color-hex" maxlength="7">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Column 3: Humidity Color Range Controls -->
            <div class="sensor-column">
                <h4 class="column-title">Humidity Colors</h4>
                <div class="color-range-group">
                    <div class="color-input-group">
                        <label for="humidHighValue">High (%):</label>
                        <div class="color-controls-container">
                            <input type="number" id="humidHighValue" value="50" min="0" max="100" class="range-input">
                            <div class="color-picker-container">
                                <input type="color" id="humidHighColor" value="#1e40af" class="color-picker">
                            </div>
                            <input type="text" id="humidHighColorHex" value="#1e40af" class="color-hex" maxlength="7">
                        </div>
                    </div>
                    <div class="color-input-group mid-row">
                        <label for="humidMidValue">Mid (%):</label>
                        <div class="color-controls-container">
                            <input type="number" id="humidMidValue" value="40" min="0" max="100" class="range-input">
                            <div class="color-picker-container">
                                <input type="color" id="humidMidColor" value="#87ceeb" class="color-picker">
                                <input type="checkbox" id="humidUseMid" class="mid-checkbox" title="Enable mid-point color">
                            </div>
                            <input type="text" id="humidMidColorHex" value="#87ceeb" class="color-hex" maxlength="7">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label for="humidLowValue">Low (%):</label>
                        <div class="color-controls-container">
                            <input type="number" id="humidLowValue" value="30" min="0" max="100" class="range-input">
                            <div class="color-picker-container">
                                <input type="color" id="humidLowColor" value="#ffffff" class="color-picker">
                            </div>
                            <input type="text" id="humidLowColorHex" value="#ffffff" class="color-hex" maxlength="7">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Column 4: Event Markers -->
            <div class="sensor-column">
                <h4 class="column-title">Event Markers</h4>
                <div class="sensor-selection-container">
                    <div class="sensor-checkbox-wrapper">
                        <input type="checkbox" id="showEventTriggers" class="sensor-checkbox" checked style="accent-color: #22c55e;">
                        <label for="showEventTriggers" class="sensor-label">Event Triggers</label>
                    </div>
                    <div class="sensor-checkbox-wrapper">
                        <input type="checkbox" id="showConfiguredEvents" class="sensor-checkbox" checked style="accent-color: #8b5cf6;">
                        <label for="showConfiguredEvents" class="sensor-label">Configured Events</label>
                    </div>
                    <div class="sensor-checkbox-wrapper">
                        <input type="checkbox" id="showThresholdEvents" class="sensor-checkbox" checked style="accent-color: #f97316;">
                        <label for="showThresholdEvents" class="sensor-label">Threshold Events</label>
                    </div>
                    <div class="sensor-checkbox-wrapper">
                        <input type="checkbox" id="showErrorLogs" class="sensor-checkbox" checked style="accent-color: #ef4444;">
                        <label for="showErrorLogs" class="sensor-label">Error Logs</label>
                    </div>
                </div>
                <div class="sensor-button-container">
                    <button id="refreshEventsButton" class="sensor-button">Refresh Events</button>
                </div>
            </div>
        </div>

        <!-- Temperature Chart -->
        <div class="chart-container">
            <h2 class="chart-title">Temperature (째F)</h2>
            <div class="chart-canvas">
                <canvas id="tempChart"></canvas>
            </div>
        </div>

        <!-- Humidity Chart -->
        <div class="chart-container">
            <h2 class="chart-title">Humidity (%)</h2>
            <div class="chart-canvas">
                <canvas id="humidityChart"></canvas>
            </div>
        </div>
        
        <!-- Time Navigation Controls -->
        <div class="time-navigation">
            <!-- Left: Start Time Controls -->
            <div class="time-control-section left">
                <div class="time-control-group">
                    <span class="time-control-label">Start Time</span>
                    <div class="time-display">
                        <span id="startTimeDisplay"></span>
                    </div>
                    <div class="time-buttons">
                        <button id="startDayMinusBtn" class="time-btn">Day -</button>
                        <button id="startHourMinusBtn" class="time-btn">Hour -</button>
                        <button id="startHourPlusBtn" class="time-btn">Hour +</button>
                        <button id="startDayPlusBtn" class="time-btn">Day +</button>
                    </div>
                </div>
            </div>
            
            <!-- Center: Range Info and Points -->
            <div class="time-control-section center">
                <div class="range-info">
                    <span id="currentTimeRange">Last 24 Hours (Live)</span>
                </div>
                <div class="points-control">
                    <label for="points" class="control-label">Points:</label>
                    <select id="points">
                        <option value="100" selected>100 points</option>
                        <option value="1000">1000 points</option>
                        <option value="10000">10000 points</option>
                    </select>
                    <button id="goLiveBtn" class="go-live-btn">Go Live</button>
                </div>
            </div>
            
            <!-- Right: End Time Controls -->
            <div class="time-control-section right">
                <div class="time-control-group">
                    <span class="time-control-label">End Time</span>
                    <div class="time-display">
                        <span id="endTimeDisplay"></span>
                    </div>
                    <div class="time-buttons">
                        <button id="endDayMinusBtn" class="time-btn">Day -</button>
                        <button id="endHourMinusBtn" class="time-btn">Hour -</button>
                        <button id="endHourPlusBtn" class="time-btn">Hour +</button>
                        <button id="endDayPlusBtn" class="time-btn">Day +</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let tempChart = null;
        let humidityChart = null;
        let autoUpdateInterval = null;
        let currentTimezone = 'America/Los_Angeles'; // Default, will be updated from server
        let availableSensors = []; // To store available sensors
        let selectedSensors = []; // To store selected sensors
        let showAverage = false; // Whether to show average of selected sensors
        
        // Performance optimization: debounce chart updates
        let updateChartsTimeout = null;
        let lastUpdateTime = 0;
        const UPDATE_DEBOUNCE_MS = 500; // Minimum time between updates

        // Time navigation state
        let isLiveMode = true;
        let currentStartTime = null; // Will be set to previous whole hour
        let currentEndTime = null; // Will be set to current time
        let timeRangeHours = 1; // Current time range in hours
        
        // Customizable color settings
        let colorSettings = {
            temperature: {
                lowValue: 70,
                midValue: 77,
                highValue: 85,
                lowColor: '#0064ff', // Blue
                midColor: '#00ff00', // green
                highColor: '#ff0000', // Red
                useMid: true
            },
            humidity: {
                lowValue: 30,
                midValue: 40,
                highValue: 50,
                lowColor: '#ffffff', // White
                midColor: '#87ceeb', // Sky blue
                highColor: '#1e40af', // Dark blue
                useMid: false
            }
        };

        // Event marker visibility settings
        let eventSettings = {
            showEventTriggers: true,
            showConfiguredEvents: true,
            showThresholdEvents: true,
            showErrorLogs: true
        };

        // Initialize time navigation
        function initializeTimeNavigation() {
            const now = new Date();
            // End time is current time
            currentEndTime = new Date(now);
            // Start time is 1 hour before current time (changed from 24 hours)
            currentStartTime = new Date(now.getTime() - (1 * 60 * 60 * 1000));
            timeRangeHours = 1; // Start with 1 hour range instead of 24
            
            console.log('Time navigation initialized:');
            console.log('Start:', currentStartTime.toISOString());
            console.log('End:', currentEndTime.toISOString());
            console.log('Range hours:', timeRangeHours);
            
            updateTimeDisplay();
            updateNavigationButtons();
        }
        
        // Update time display
        function updateTimeDisplay() {
            const timeRangeElement = document.getElementById('currentTimeRange');
            const startTimeElement = document.getElementById('startTimeDisplay');
            const endTimeElement = document.getElementById('endTimeDisplay');
            
            if (isLiveMode) {
                const duration = timeRangeHours === 1 ? 'Last Hour' : 
                               timeRangeHours === 24 ? 'Last 24 Hours' : 
                               `Last ${timeRangeHours} Hours`;
                timeRangeElement.textContent = `${duration} (Live)`;
                endTimeElement.textContent = 'Now';
            } else {
                const duration = timeRangeHours === 1 ? '1 Hour' : 
                               timeRangeHours === 24 ? '1 Day' : 
                               `${timeRangeHours} Hours`;
                timeRangeElement.textContent = `${duration} (Historical)`;
                endTimeElement.textContent = currentEndTime.toLocaleString();
            }
            
            startTimeElement.textContent = currentStartTime.toLocaleString();
        }
        
        // Update navigation button states
        function updateNavigationButtons() {
            const now = new Date();
            
            // End time buttons - disabled if we're at or past current time
            const canIncreaseEndTime = currentEndTime < now;
            document.getElementById('endHourPlusBtn').disabled = !canIncreaseEndTime;
            document.getElementById('endDayPlusBtn').disabled = !canIncreaseEndTime;
            
            // Start time buttons - disabled if start would be after end
            const canIncreaseStartTime = (currentStartTime.getTime() + (60 * 60 * 1000)) < currentEndTime.getTime();
            const canIncreaseStartTimeDay = (currentStartTime.getTime() + (24 * 60 * 60 * 1000)) < currentEndTime.getTime();
            document.getElementById('startHourPlusBtn').disabled = !canIncreaseStartTime;
            document.getElementById('startDayPlusBtn').disabled = !canIncreaseStartTimeDay;
            
            // Update button styles for disabled state
            const buttons = ['endHourPlusBtn', 'endDayPlusBtn', 'startHourPlusBtn', 'startDayPlusBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                btn.style.opacity = btn.disabled ? '0.5' : '1';
            });
            
            // Update Go Live button state
            updateGoLiveButton();
        }
        
        // Go Live function
        function goLive() {
            isLiveMode = true;
            const now = new Date();
            
            // Set up live mode: end time is now, start time is 1 hour before
            currentEndTime = new Date(now);
            currentStartTime = new Date(now.getTime() - (1 * 60 * 60 * 1000));
            timeRangeHours = 1;
            
            console.log('Switched to live mode');
            updateTimeDisplay();
            updateNavigationButtons();
            updateGoLiveButton();
            updateCharts();
        }
        
        // Update Go Live button state
        function updateGoLiveButton() {
            const goLiveBtn = document.getElementById('goLiveBtn');
            if (isLiveMode) {
                goLiveBtn.disabled = true;
                goLiveBtn.textContent = 'Live';
            } else {
                goLiveBtn.disabled = false;
                goLiveBtn.textContent = 'Go Live';
            }
        }
        
        // Individual time control functions
        function adjustStartTime(hours) {
            isLiveMode = false; // Exit live mode when manually adjusting
            currentStartTime = new Date(currentStartTime.getTime() + (hours * 60 * 60 * 1000));
            
            // Recalculate time range
            const timeRangeMs = currentEndTime.getTime() - currentStartTime.getTime();
            timeRangeHours = timeRangeMs / (1000 * 60 * 60);
            
            updateTimeDisplay();
            updateNavigationButtons();
            updateGoLiveButton();
            updateCharts();
        }
        
        function adjustEndTime(hours) {
            isLiveMode = false; // Exit live mode when manually adjusting
            currentEndTime = new Date(currentEndTime.getTime() + (hours * 60 * 60 * 1000));
            
            // Recalculate time range
            const timeRangeMs = currentEndTime.getTime() - currentStartTime.getTime();
            timeRangeHours = timeRangeMs / (1000 * 60 * 60);
            
            updateTimeDisplay();
            updateNavigationButtons();
            updateGoLiveButton();
            updateCharts();
        }

        // Chart colors for different sensors (can add more as needed)
        const tempColors = [
            { border: 'rgb(255, 99, 132)', background: 'rgba(255, 99, 132, 0.1)' },  // Red
            { border: 'rgb(220, 38, 38)', background: 'rgba(220, 38, 38, 0.1)' },   // Darker Red
            { border: 'rgb(239, 68, 68)', background: 'rgba(239, 68, 68, 0.1)' },   // Medium Red
            { border: 'rgb(252, 165, 165)', background: 'rgba(252, 165, 165, 0.1)' }, // Light Red
            { border: 'rgb(153, 27, 27)', background: 'rgba(153, 27, 27, 0.1)' }    // Deep Red
        ];
        const humidColors = [
            { border: 'rgb(54, 162, 235)', background: 'rgba(54, 162, 235, 0.1)' },  // Blue
            { border: 'rgb(37, 99, 235)', background: 'rgba(37, 99, 235, 0.1)' },   // Darker Blue
            { border: 'rgb(59, 130, 246)', background: 'rgba(59, 130, 246, 0.1)' }, // Medium Blue
            { border: 'rgb(191, 219, 254)', background: 'rgba(191, 219, 254, 0.1)' }, // Light Blue
            { border: 'rgb(30, 64, 175)', background: 'rgba(30, 64, 175, 0.1)' }    // Deep Blue
        ];

        // Function to get color based on temperature value
        function getTemperatureColor(tempF) {
            if (tempF === null || tempF === undefined) return 'rgba(128, 128, 128, 0.5)'; // Gray for null values
            
            const settings = colorSettings.temperature;
            const lowValue = settings.lowValue;
            const midValue = settings.midValue;
            const highValue = settings.highValue;
            const lowColor = settings.lowColor;
            const midColor = settings.midColor;
            const highColor = settings.highColor;
            const useMid = settings.useMid;
            
            // Convert hex colors to RGB
            const lowRGB = hexToRgb(lowColor);
            const midRGB = hexToRgb(midColor);
            const highRGB = hexToRgb(highColor);
            
            if (!useMid) {
                // Simple interpolation between low and high (ignore mid)
                const clampedTemp = Math.max(lowValue, Math.min(highValue, tempF));
                const ratio = (clampedTemp - lowValue) / (highValue - lowValue);
                
                const r = Math.round(lowRGB.r + (highRGB.r - lowRGB.r) * ratio);
                const g = Math.round(lowRGB.g + (highRGB.g - lowRGB.g) * ratio);
                const b = Math.round(lowRGB.b + (highRGB.b - lowRGB.b) * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Two-stage interpolation: low->mid and mid->high
                if (tempF <= midValue) {
                    // Interpolate between low and mid
                    const clampedTemp = Math.max(lowValue, Math.min(midValue, tempF));
                    const ratio = (clampedTemp - lowValue) / (midValue - lowValue);
                    
                    const r = Math.round(lowRGB.r + (midRGB.r - lowRGB.r) * ratio);
                    const g = Math.round(lowRGB.g + (midRGB.g - lowRGB.g) * ratio);
                    const b = Math.round(lowRGB.b + (midRGB.b - lowRGB.b) * ratio);
                    
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Interpolate between mid and high
                    const clampedTemp = Math.max(midValue, Math.min(highValue, tempF));
                    const ratio = (clampedTemp - midValue) / (highValue - midValue);
                    
                    const r = Math.round(midRGB.r + (highRGB.r - midRGB.r) * ratio);
                    const g = Math.round(midRGB.g + (highRGB.g - midRGB.g) * ratio);
                    const b = Math.round(midRGB.b + (highRGB.b - midRGB.b) * ratio);
                    
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
        }

        // Function to get color based on humidity value
        function getHumidityColor(humidity) {
            if (humidity === null || humidity === undefined) return 'rgba(128, 128, 128, 0.5)'; // Gray for null values
            
            const settings = colorSettings.humidity;
            const lowValue = settings.lowValue;
            const midValue = settings.midValue;
            const highValue = settings.highValue;
            const lowColor = settings.lowColor;
            const midColor = settings.midColor;
            const highColor = settings.highColor;
            const useMid = settings.useMid;
            
            // Convert hex colors to RGB
            const lowRGB = hexToRgb(lowColor);
            const midRGB = hexToRgb(midColor);
            const highRGB = hexToRgb(highColor);
            
            if (!useMid) {
                // Simple interpolation between low and high (ignore mid)
                const clampedHumidity = Math.max(lowValue, Math.min(highValue, humidity));
                const ratio = (clampedHumidity - lowValue) / (highValue - lowValue);
                
                const r = Math.round(lowRGB.r + (highRGB.r - lowRGB.r) * ratio);
                const g = Math.round(lowRGB.g + (highRGB.g - lowRGB.g) * ratio);
                const b = Math.round(lowRGB.b + (highRGB.b - lowRGB.b) * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Two-stage interpolation: low->mid and mid->high
                if (humidity <= midValue) {
                    // Interpolate between low and mid
                    const clampedHumidity = Math.max(lowValue, Math.min(midValue, humidity));
                    const ratio = (clampedHumidity - lowValue) / (midValue - lowValue);
                    
                    const r = Math.round(lowRGB.r + (midRGB.r - lowRGB.r) * ratio);
                    const g = Math.round(lowRGB.g + (midRGB.g - lowRGB.g) * ratio);
                    const b = Math.round(lowRGB.b + (midRGB.b - lowRGB.b) * ratio);
                    
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Interpolate between mid and high
                    const clampedHumidity = Math.max(midValue, Math.min(highValue, humidity));
                    const ratio = (clampedHumidity - midValue) / (highValue - midValue);
                    
                    const r = Math.round(midRGB.r + (highRGB.r - midRGB.r) * ratio);
                    const g = Math.round(midRGB.g + (highRGB.g - midRGB.g) * ratio);
                    const b = Math.round(midRGB.b + (highRGB.b - midRGB.b) * ratio);
                    
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
        }

        // Helper function to convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Function to create point colors array based on data values
        function createPointColors(dataPoints, type) {
            return dataPoints.map(point => {
                if (point.y === null || point.y === undefined) {
                    return 'rgba(128, 128, 128, 0.5)'; // Gray for null values
                }
                
                if (type === 'temperature') {
                    return getTemperatureColor(point.y);
                } else if (type === 'humidity') {
                    return getHumidityColor(point.y);
                }
                
                return 'rgba(128, 128, 128, 0.8)'; // Default gray
            });
        }

        // Initialize socket connection
        const socket = io();
        
        // Event data will be fetched and added as chart data points
        
        // Function to generate simple time reference lines (midnight and noon)
        function generateTimeReferenceLines(startDateMs, endDateMs) {
            const lines = [];
            const startDate = new Date(startDateMs);
            const endDate = new Date(endDateMs);
            
            // Create a date iterator starting from the start date
            const currentDate = new Date(startDate);
            currentDate.setHours(0, 0, 0, 0); // Start at midnight of the start date
            
            while (currentDate <= endDate) {
                const midnightTime = new Date(currentDate);
                const noonTime = new Date(currentDate);
                noonTime.setHours(12, 0, 0, 0);
                
                // Add midnight line (light blue)
                if (midnightTime >= startDate && midnightTime <= endDate) {
                    lines.push({
                        type: 'line',
                        xMin: midnightTime.getTime(),
                        xMax: midnightTime.getTime(),
                        borderColor: '#60a5fa', // Light blue
                        borderWidth: 1,
                        borderDash: [3, 3],
                        label: {
                            display: false // No labels
                        }
                    });
                }
                
                // Add noon line (yellow)
                if (noonTime >= startDate && noonTime <= endDate) {
                    lines.push({
                        type: 'line',
                        xMin: noonTime.getTime(),
                        xMax: noonTime.getTime(),
                        borderColor: '#eab308', // Yellow
                        borderWidth: 1,
                        borderDash: [3, 3],
                        label: {
                            display: false // No labels
                        }
                    });
                }
                
                // Move to next day
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            return lines;
        }

        // Function to fetch event data for the time range
        async function fetchEventData(startDateMs, endDateMs, type) {
            const events = [];
            const startDate = new Date(startDateMs).toISOString();
            const endDate = new Date(endDateMs).toISOString();
            
            console.log(`Fetching ${type} event data for time range:`, startDate, 'to', endDate);
            
            try {
                // 1. Event Triggers (actual executions) - Green circles
                if (eventSettings.showEventTriggers) {
                    const eventResponse = await fetch(`/api/event-triggers?startDate=${startDate}&endDate=${endDate}`);
                    if (eventResponse.ok) {
                        const eventTriggers = await eventResponse.json();
                        eventTriggers.forEach(event => {
                            const eventTime = new Date(event.timestamp).getTime();
                            if (eventTime >= startDateMs && eventTime <= endDateMs) {
                                const percentage = Math.round((event.pwm_value / 1023) * 100);
                                events.push({
                                    x: eventTime,
                                    y: null, // Will be interpolated
                                    eventType: 'trigger',
                                    eventData: {
                                        type: 'Event Triggered',
                                        gpio: event.gpio,
                                        pwm: event.pwm_value,
                                        percentage: percentage,
                                        triggerType: event.trigger_type || 'time',
                                        eventName: event.event_name,
                                        timestamp: event.timestamp
                                    }
                                });
                            }
                        });
                    }
                }
                
                // 2. Configured Events (scheduled times) - Purple squares
                if (eventSettings.showConfiguredEvents) {
                    const configResponse = await fetch('/api/configured-events');
                    if (configResponse.ok) {
                        const configuredEvents = await configResponse.json();
                        configuredEvents.forEach(event => {
                            if (event.trigger_type === 'time' || !event.trigger_type) {
                                const timeStr = event.time;
                                const [hours, minutes, seconds] = timeStr.split(':').map(Number);
                                
                                // Generate markers for each day in the range
                                const startDay = new Date(startDateMs);
                                const endDay = new Date(endDateMs);
                                
                                for (let day = new Date(startDay); day <= endDay; day.setDate(day.getDate() + 1)) {
                                    const eventDateTime = new Date(day);
                                    eventDateTime.setUTCHours(hours, minutes, seconds, 0);
                                    const eventTime = eventDateTime.getTime();
                                    
                                    if (eventTime >= startDateMs && eventTime <= endDateMs) {
                                        const percentage = Math.round((event.pwm_value / 1023) * 100);
                                        events.push({
                                            x: eventTime,
                                            y: null, // Will be interpolated
                                            eventType: 'configured',
                                            eventData: {
                                                type: 'Scheduled Event',
                                                gpio: event.gpio,
                                                pwm: event.pwm_value,
                                                percentage: percentage,
                                                priority: event.priority || 1,
                                                status: event.enabled ? 'ENABLED' : 'DISABLED',
                                                eventName: event.event_name,
                                                timestamp: eventTime
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    }
                }
                
                // 3. Threshold Events - Orange diamonds
                if (eventSettings.showThresholdEvents) {
                    const configResponse = await fetch('/api/configured-events');
                    if (configResponse.ok) {
                        const configuredEvents = await configResponse.json();
                        configuredEvents.forEach(event => {
                            if (event.trigger_type && event.trigger_type !== 'time' && event.threshold_value !== undefined) {
                                // For threshold events, we'll place them at a representative time
                                const midTime = startDateMs + (endDateMs - startDateMs) / 2;
                                const percentage = Math.round((event.pwm_value / 1023) * 100);
                                const unit = event.sensor_type === 'temperature' ? '째F' : '%';
                                const condition = event.threshold_condition === 'greater_than' ? 'above' : 'below';
                                const lastTriggered = event.last_triggered_at ? 
                                    new Date(event.last_triggered_at).toLocaleString() : 'Never';
                                
                                // Only add if it matches the chart type
                                if ((type === 'temperature' && event.sensor_type === 'temperature') ||
                                    (type === 'humidity' && event.sensor_type === 'humidity')) {
                                    events.push({
                                        x: midTime,
                                        y: event.threshold_value, // Use threshold value as Y position
                                        eventType: 'threshold',
                                        eventData: {
                                            type: 'Threshold Event',
                                            sensor: event.sensor_address,
                                            condition: `${condition} ${event.threshold_value}${unit}`,
                                            gpio: event.gpio,
                                            pwm: event.pwm_value,
                                            percentage: percentage,
                                            priority: event.priority || 1,
                                            cooldown: `${event.cooldown_minutes || 5} min`,
                                            status: event.enabled ? 'ENABLED' : 'DISABLED',
                                            lastTriggered: lastTriggered
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
                
                // 4. Error Logs - Red triangles
                if (eventSettings.showErrorLogs) {
                    const errorResponse = await fetch(`/api/error-logs?startDate=${startDate}&endDate=${endDate}`);
                    if (errorResponse.ok) {
                        const errorLogs = await errorResponse.json();
                        errorLogs.forEach(error => {
                            const errorTime = new Date(error.timestamp).getTime();
                            if (errorTime >= startDateMs && errorTime <= endDateMs) {
                                events.push({
                                    x: errorTime,
                                    y: null, // Will be interpolated
                                    eventType: 'error',
                                    eventData: {
                                        type: `${(error.severity || 'ERROR').toUpperCase()}`,
                                        message: error.message,
                                        component: error.component || 'System',
                                        details: error.details,
                                        timestamp: error.timestamp
                                    }
                                });
                            }
                        });
                    }
                }
                
            } catch (error) {
                console.log('Error fetching event data:', error);
            }
            
            console.log(`Found ${events.length} events for ${type} chart`);
            return events;
        }
        
        // Function to interpolate Y value for events based on existing sensor data
        function interpolateEventValue(eventX, sensorData, type) {
            if (!sensorData || sensorData.length === 0) {
                // No sensor data available, place at middle of typical range
                return type === 'temperature' ? 75 : 50;
            }
            
            // Sort data by timestamp
            const sortedData = sensorData.sort((a, b) => a.x - b.x);
            
            // Find the closest data points before and after the event
            let beforePoint = null;
            let afterPoint = null;
            
            for (let i = 0; i < sortedData.length; i++) {
                const point = sortedData[i];
                if (point.y === null || point.y === undefined) continue;
                
                if (point.x <= eventX) {
                    beforePoint = point;
                } else if (point.x > eventX && !afterPoint) {
                    afterPoint = point;
                    break;
                }
            }
            
            // Interpolate between the two points
            if (beforePoint && afterPoint) {
                const timeDiff = afterPoint.x - beforePoint.x;
                const valueDiff = afterPoint.y - beforePoint.y;
                const eventTimeDiff = eventX - beforePoint.x;
                const ratio = eventTimeDiff / timeDiff;
                return beforePoint.y + (valueDiff * ratio);
            } else if (beforePoint) {
                // Only have a point before, use that value
                return beforePoint.y;
            } else if (afterPoint) {
                // Only have a point after, use that value
                return afterPoint.y;
            } else {
                // No valid data points, use middle of typical range
                return type === 'temperature' ? 75 : 50;
            }
        }

        // Handle timezone updates from server
        socket.on('timezoneUpdate', (data) => {
            currentTimezone = data.timezone;
            updateTime();
        });

        function updateTime() {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                hour12: true
            });
            const timeString = formatter.format(now);
            const timezoneAbbr = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                timeZoneName: 'short'
            }).formatToParts(now).find(part => part.type === 'timeZoneName').value;
            document.getElementById('currentTime').textContent = `${timeString} ${timezoneAbbr}`;
        }

        // Fetch available sensors from the server
        function fetchSensors() {
            console.log('Fetching sensors from server...');
            fetch('/api/sensors')
                .then(response => {
                    console.log('Sensor API response status:', response.status);
                    console.log('Sensor API response headers:', response.headers);
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Sensors loaded successfully:', data);
                    console.log('Number of sensors:', data.length);
                    availableSensors = data;
                    
                    // Select all by default - use address as the identifier since sensors don't have id
                    selectedSensors = availableSensors.map(s => s.address);
                    console.log('Selected sensors:', selectedSensors);
                    
                    // Render sensor selection UI
                    renderSensorSelection();
                    
                    // Update charts with the newly selected sensors
                    debouncedUpdateCharts();
                })
                .catch(error => {
                    console.error('Error fetching sensors:', error);
                    console.error('Error details:', error.message, error.stack);
                    document.getElementById('sensorSelectionContainer').innerHTML = 
                        `<div class="error-message">Error loading sensors: ${error.message}. Please refresh the page to try again.</div>`;
                    
                    // Try to continue with default sensors to prevent complete failure
                    console.log('Falling back to default sensors');
                    availableSensors = [
                        { id: 1, address: '0x38', type: 'AHT10', name: 'AHT10 0x38' },
                        { id: 2, address: '0x39', type: 'AHT10', name: 'AHT10 0x39' }
                    ];
                    selectedSensors = availableSensors.map(s => s.address);
                    renderSensorSelection();
                    debouncedUpdateCharts();
                });
        }

        // Render the sensor selection checkboxes
        function renderSensorSelection() {
            const container = document.getElementById('sensorSelectionContainer');
            container.innerHTML = ''; // Clear container
            
            if (availableSensors.length === 0) {
                container.innerHTML = '<div class="empty-state">No sensors configured yet.</div>';
                return;
            }
            
            availableSensors.forEach((sensor, index) => {
                const isSelected = selectedSensors.includes(sensor.address);
                // Always use dark gray for accent color
                const color = '#333';
                
                const wrapper = document.createElement('div');
                wrapper.className = 'sensor-checkbox-wrapper';
                
                // Create a safe ID by replacing special characters
                const safeId = sensor.address.replace(/[^a-zA-Z0-9]/g, '_');
                
                wrapper.innerHTML = `
                    <input type="checkbox" id="sensor-${safeId}" class="sensor-checkbox" 
                           ${isSelected ? 'checked' : ''} data-sensor-id="${sensor.address}"
                           style="accent-color: ${color};">
                    <label for="sensor-${safeId}" class="sensor-label">
                        ${sensor.name || `${sensor.type} ${sensor.address}`}
                    </label>
                `;
                
                const checkbox = wrapper.querySelector('.sensor-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedSensors.push(sensor.address);
                    } else {
                        selectedSensors = selectedSensors.filter(id => id !== sensor.address);
                    }
                    debouncedUpdateCharts();
                });
                
                container.appendChild(wrapper);
            });
        }

        // Function to handle "Select All" button
        function selectAllSensors() {
            selectedSensors = availableSensors.map(s => s.address);
            document.querySelectorAll('.sensor-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
            debouncedUpdateCharts();
        }

        // Function to handle "Deselect All" button
        function deselectAllSensors() {
            selectedSensors = [];
            document.querySelectorAll('.sensor-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            debouncedUpdateCharts();
        }

        // Function to toggle average mode
        function toggleAverageMode() {
            showAverage = !showAverage;
            console.log(`Toggle average mode: ${showAverage ? 'ON' : 'OFF'}`);
            document.getElementById('averageSensors').textContent = showAverage ? 'Show Individual' : 'Show Average';
            
            // Clear and regenerate charts with new mode
            debouncedUpdateCharts();
        }

        // Function to sync color picker with hex input
        function syncColorInputs(colorPickerId, hexInputId) {
            const colorPicker = document.getElementById(colorPickerId);
            const hexInput = document.getElementById(hexInputId);
            
            colorPicker.addEventListener('input', function() {
                hexInput.value = this.value;
            });
            
            hexInput.addEventListener('input', function() {
                const hex = this.value;
                if (/^#[0-9A-F]{6}$/i.test(hex)) {
                    colorPicker.value = hex;
                }
            });
        }

        // Function to update color settings from UI controls
        function updateColorSettings() {
            colorSettings.temperature.lowValue = parseInt(document.getElementById('tempLowValue').value);
            colorSettings.temperature.midValue = parseInt(document.getElementById('tempMidValue').value);
            colorSettings.temperature.highValue = parseInt(document.getElementById('tempHighValue').value);
            colorSettings.temperature.lowColor = document.getElementById('tempLowColor').value;
            colorSettings.temperature.midColor = document.getElementById('tempMidColor').value;
            colorSettings.temperature.highColor = document.getElementById('tempHighColor').value;
            colorSettings.temperature.useMid = document.getElementById('tempUseMid').checked;
            
            colorSettings.humidity.lowValue = parseInt(document.getElementById('humidLowValue').value);
            colorSettings.humidity.midValue = parseInt(document.getElementById('humidMidValue').value);
            colorSettings.humidity.highValue = parseInt(document.getElementById('humidHighValue').value);
            colorSettings.humidity.lowColor = document.getElementById('humidLowColor').value;
            colorSettings.humidity.midColor = document.getElementById('humidMidColor').value;
            colorSettings.humidity.highColor = document.getElementById('humidHighColor').value;
            colorSettings.humidity.useMid = document.getElementById('humidUseMid').checked;
            
            // Update hex inputs to match color pickers
            document.getElementById('tempLowColorHex').value = colorSettings.temperature.lowColor;
            document.getElementById('tempMidColorHex').value = colorSettings.temperature.midColor;
            document.getElementById('tempHighColorHex').value = colorSettings.temperature.highColor;
            document.getElementById('humidLowColorHex').value = colorSettings.humidity.lowColor;
            document.getElementById('humidMidColorHex').value = colorSettings.humidity.midColor;
            document.getElementById('humidHighColorHex').value = colorSettings.humidity.highColor;
            
            console.log('Color settings updated:', colorSettings);
            
            // Regenerate charts with new colors
            debouncedUpdateCharts();
        }
        
        // Helper function to create chart
        function createChart(ctx, type, timeRange, startDateMs, endDateMs) {
            // Function to generate clean tick timestamps
            function generateTicks(timeRange, startDateMs, endDateMs) {
                const ticks = [];
                const startDate = new Date(startDateMs);
                const endDate = new Date(endDateMs);
                
                if (timeRange === 1) { // Last Hour - every 5 minutes
                    // Start from the nearest 5-minute mark before startDate
                    const start = new Date(startDate);
                    start.setMinutes(Math.floor(start.getMinutes() / 5) * 5, 0, 0);
                    
                    for (let time = new Date(start); time <= endDate; time.setMinutes(time.getMinutes() + 5)) {
                        if (time >= startDate) {
                            ticks.push(time.getTime());
                        }
                    }
                } else if (timeRange === 24) { // Last 24 Hours - every hour
                    // Start from the nearest hour before startDate
                    const start = new Date(startDate);
                    start.setMinutes(0, 0, 0);
                    
                    for (let time = new Date(start); time <= endDate; time.setHours(time.getHours() + 1)) {
                        if (time >= startDate) {
                            ticks.push(time.getTime());
                        }
                    }
                } else if (timeRange === 168) { // Last Week - every 12 hours (midnight & noon)
                    // Start from the nearest 12-hour mark before startDate
                    const start = new Date(startDate);
                    const hour = start.getHours();
                    if (hour < 12) {
                        start.setHours(0, 0, 0, 0);
                    } else {
                        start.setHours(12, 0, 0, 0);
                    }
                    
                    for (let time = new Date(start); time <= endDate; time.setHours(time.getHours() + 12)) {
                        if (time >= startDate) {
                            ticks.push(time.getTime());
                        }
                    }
                }
                
                return ticks;
            }
            
            console.log(`Chart timeRange: ${timeRange} hours`);
            
            // Generate custom ticks for clean time boundaries
            const customTicks = generateTicks(timeRange, startDateMs, endDateMs);
            
            // Calculate clean starting boundary
            let cleanStartMs = startDateMs;
            if (timeRange === 1) { // Last Hour - round to nearest 5 minutes
                const startDate = new Date(startDateMs);
                startDate.setMinutes(Math.floor(startDate.getMinutes() / 5) * 5, 0, 0);
                cleanStartMs = startDate.getTime();
            } else if (timeRange === 24) { // Last 24 Hours - round to nearest hour
                const startDate = new Date(startDateMs);
                startDate.setMinutes(0, 0, 0);
                cleanStartMs = startDate.getTime();
            } else if (timeRange === 168) { // Last Week - round to nearest 12 hours
                const startDate = new Date(startDateMs);
                const hour = startDate.getHours();
                if (hour < 12) {
                    startDate.setHours(0, 0, 0, 0);
                } else {
                    startDate.setHours(12, 0, 0, 0);
                }
                cleanStartMs = startDate.getTime();
            }
            
            const chartConfig = {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    parsing: false,
                    spanGaps: false,
                    animation: false, // Disable all animations
                    animations: false, // Disable all animations
                    transitions: {
                        active: {
                            animation: {
                                duration: 0
                            }
                        },
                        resize: {
                            animation: {
                                duration: 0
                            }
                        },
                        show: {
                            animation: {
                                duration: 0
                            }
                        },
                        hide: {
                            animation: {
                                duration: 0
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    },
                    elements: {
                        point: {
                            radius: 3, // Smaller default radius
                            hoverRadius: 5, // Smaller hover radius
                            pointStyle: 'circle', // Use hollow circles
                            backgroundColor: 'transparent', // Make points hollow
                            borderWidth: 2 // Thicker border for hollow rings
                        },
                        line: {
                            tension: 0,
                            borderWidth: 2
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: cleanStartMs,
                            max: endDateMs,
                            time: {
                                displayFormats: {
                                    millisecond: 'h:mm:ss.SSS a',
                                    second: 'h:mm:ss a',
                                    minute: 'h:mm a',
                                    hour: 'MMM d, h:mm a',
                                    day: 'MMM d',
                                    week: 'MMM d',
                                    month: 'MMM yyyy',
                                    quarter: 'MMM yyyy',
                                    year: 'yyyy'
                                },
                                tooltipFormat: 'MMM d, yyyy, h:mm:ss a'
                            },
                            adapters: {
                                date: {
                                  locale: 'en-US'
                                }
                            },
                            distribution: 'linear',
                            bounds: 'data',
                            offset: false,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e8e6e3',
                                maxRotation: 45,
                                minRotation: 45,
                                major: {
                                    enabled: true
                                },
                                font: {
                                    size: 10
                                },
                                afterBuildTicks: function(scale) {
                                    // Replace Chart.js ticks with our custom ones
                                    scale.ticks = customTicks.map(tickValue => ({
                                        value: tickValue,
                                        major: false
                                    }));
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e8e6e3'
                            },
                            title: {
                                display: true,
                                text: type === 'temperature' ? 'Temperature (째F)' : 'Humidity (%)',
                                color: '#e8e6e3'
                            },
                            min: type === 'temperature' ? 50 : 0,
                            max: 100,
                            beginAtZero: type === 'humidity'
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e8e6e3',
                                padding: 10,
                                usePointStyle: true,
                                pointStyle: 'circle'
                            },
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'point',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            borderWidth: 2,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                title: function(context) {
                                    // Safety checks to prevent null reference errors
                                    if (!context || !context[0] || !context[0].parsed) {
                                        return 'No timestamp';
                                    }
                                    
                                    const point = context[0];
                                    const timestamp = new Date(point.parsed.x);
                                    return timestamp.toLocaleString();
                                },
                                label: function(context) {
                                    // Safety checks to prevent null reference errors
                                    if (!context || !context.raw || !context.dataset) {
                                        return 'No data';
                                    }
                                    
                                    const point = context.raw;
                                    const dataset = context.dataset;
                                    
                                    // Check if this is an event point
                                    if (point && point.eventType) {
                                        const lines = [` ${point.eventData.type}`];
                                        
                                        // Add event-specific information
                                        if (point.eventType === 'trigger') {
                                            lines.push(`GPIO${point.eventData.gpio}  ${point.eventData.pwm} (${point.eventData.percentage}%)`);
                                            lines.push(`Trigger: ${point.eventData.triggerType}`);
                                            if (point.eventData.eventName) {
                                                lines.push(`Event: ${point.eventData.eventName}`);
                                            }
                                        } else if (point.eventType === 'configured') {
                                            lines.push(`GPIO${point.eventData.gpio}  ${point.eventData.pwm} (${point.eventData.percentage}%)`);
                                            lines.push(`Priority: ${point.eventData.priority}`);
                                            lines.push(`Status: ${point.eventData.status}`);
                                            if (point.eventData.eventName) {
                                                lines.push(`Event: ${point.eventData.eventName}`);
                                            }
                                        } else if (point.eventType === 'threshold') {
                                            lines.push(`Sensor: ${point.eventData.sensor}`);
                                            lines.push(`Condition: ${point.eventData.condition}`);
                                            lines.push(`GPIO${point.eventData.gpio}  ${point.eventData.pwm} (${point.eventData.percentage}%)`);
                                            lines.push(`Priority: ${point.eventData.priority}`);
                                            lines.push(`Cooldown: ${point.eventData.cooldown}`);
                                            lines.push(`Status: ${point.eventData.status}`);
                                            lines.push(`Last triggered: ${point.eventData.lastTriggered}`);
                                        } else if (point.eventType === 'error') {
                                            lines.push(`Message: ${point.eventData.message}`);
                                            lines.push(`Component: ${point.eventData.component}`);
                                            if (point.eventData.details) {
                                                lines.push(`Details: ${point.eventData.details}`);
                                            }
                                        }
                                        
                                        // Add interpolated value info
                                        if (point.y !== null && point.y !== undefined) {
                                            const unit = type === 'temperature' ? '째F' : '%';
                                            lines.push(`Interpolated ${type}: ${point.y.toFixed(1)}${unit}`);
                                        }
                                        
                                        return lines;
                                    } else {
                                        // Regular sensor data point
                                        const unit = type === 'temperature' ? '째F' : '%';
                                        return `${dataset.label}: ${point.y.toFixed(1)}${unit}`;
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: [] // Will be populated with time reference lines
                        }
                    }
                }
            };
            
            const chart = new Chart(ctx, chartConfig);
            
            // Add time reference lines after chart creation
            if (chart.options.plugins && chart.options.plugins.annotation) {
                chart.options.plugins.annotation.annotations = generateTimeReferenceLines(startDateMs, endDateMs);
                chart.update('none');
            }
            
            return chart;
        }

        // Function to fetch and display data for a chart
        function fetchAndUpdateChart(url, type, timeRange, startDateMs, endDateMs) {
            if (selectedSensors.length === 0) {
                console.log('No sensors selected, clearing chart');
                // Clear chart if no sensors selected
                if (type === 'temperature' && tempChart) {
                    try {
                        tempChart.destroy();
                    } catch (error) {
                        console.warn('Error destroying temperature chart:', error);
                    }
                    tempChart = null;
                    const container = document.getElementById('tempChart').parentNode;
                    container.innerHTML = '<canvas id="tempChart"></canvas>';
                } else if (type === 'humidity' && humidityChart) {
                    try {
                        humidityChart.destroy();
                    } catch (error) {
                        console.warn('Error destroying humidity chart:', error);
                    }
                    humidityChart = null;
                    const container = document.getElementById('humidityChart').parentNode;
                    container.innerHTML = '<canvas id="humidityChart"></canvas>';
                }
                return;
            }
            
            // Add selected sensors to URL
            const sensorIds = selectedSensors.join(',');
            url.searchParams.set('sensors', sensorIds);
            console.log(`Fetching data for sensors: ${sensorIds}`);
            
            // Add average flag if needed
            if (showAverage) {
                url.searchParams.set('average', 'true');
            }

            console.log(`Fetching URL: ${url.toString()}`);

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`API returned ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('API Response:', data);
                    
                    // Get existing chart reference
                    let chart = type === 'temperature' ? tempChart : humidityChart;
                    
                    // If chart doesn't exist, create it
                    if (!chart) {
                        // Ensure we have a clean canvas element
                        const canvasId = type === 'temperature' ? 'tempChart' : 'humidityChart';
                        let canvas = document.getElementById(canvasId);
                        
                        // If canvas doesn't exist or is corrupted, recreate it
                        if (!canvas || !canvas.getContext) {
                            const container = canvas ? canvas.parentNode : document.querySelector(`#${canvasId}`).parentNode;
                            container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                            canvas = document.getElementById(canvasId);
                        }
                        
                        // Ensure canvas is properly sized
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';
                        
                        const ctx = canvas.getContext('2d');
                        if (!ctx) {
                            console.error(`Failed to get 2D context for ${canvasId}`);
                            return;
                        }
                        
                        // Create new chart
                        chart = createChart(ctx, type, timeRange, startDateMs, endDateMs);
                        
                        if (type === 'temperature') {
                            tempChart = chart;
                        } else {
                            humidityChart = chart;
                        }
                    }
                    
                    // Clear existing datasets
                    chart.data.datasets = [];
                    
                    // Update time range - ensure this happens before processing data
                    chart.options.scales.x.min = startDateMs;
                    chart.options.scales.x.max = endDateMs;
                    
                    console.log(`Chart time range updated: ${new Date(startDateMs).toISOString()} to ${new Date(endDateMs).toISOString()}`);
                    
                    // No data case
                    if (!data || data.length === 0) {
                        // Even with no data, set the time range to show a complete axis
                        if (startDateMs && endDateMs) {
                            chart.options.scales.x.min = startDateMs;
                            chart.options.scales.x.max = endDateMs;
                            chart.update('none'); // Update without animation for immediate response
                        }
                        
                        // Display "No data" message
                        const canvasId = type === 'temperature' ? 'tempChart' : 'humidityChart';
                        const container = document.getElementById(canvasId).parentNode;
                        const ctx = document.getElementById(canvasId).getContext('2d');
                        ctx.font = '16px Arial';
                        ctx.fillStyle = '#e8e6e3';
                        ctx.textAlign = 'center';
                        ctx.fillText('No data available for selected sensors', container.clientWidth / 2, container.clientHeight / 2);
                        return;
                    }
                    
                    // Process data based on mode
                    if (showAverage) {
                        // Average mode - single dataset
                        const dataPoints = data.map(point => ({
                            x: new Date(point.timestamp).valueOf(),
                            y: point.value
                        })).filter(p => p.y !== null);
                        
                        // Only add dataset if we have points
                        if (dataPoints.length > 0) {
                            // Calculate min/max for better y-axis scaling
                            const values = dataPoints.map(p => p.y);
                            const min = Math.min(...values);
                            const max = Math.max(...values);
                            const padding = (max - min) * 0.1;
                            
                            // Update y-axis scale
                            chart.options.scales.y.min = type === 'humidity' ? Math.max(0, min - padding) : Math.max(50, min - padding);
                            chart.options.scales.y.max = type === 'humidity' ? Math.min(100, max + padding) : max + padding;
                        
                            // Create point colors based on values
                            const pointColors = createPointColors(dataPoints, type);
                            
                            chart.data.datasets.push({
                                label: `Average ${type === 'temperature' ? 'Temperature (째F)' : 'Humidity (%)'}`,
                                data: dataPoints,
                                borderColor: 'rgba(255, 255, 255, 0.3)', // Light border for connection lines
                                backgroundColor: 'transparent', // Transparent background for hollow rings
                                pointBackgroundColor: 'transparent', // Hollow points
                                pointBorderColor: pointColors, // Border color matches value-based colors
                                pointBorderWidth: 2, // Thicker border for visibility
                                pointRadius: 3, // Consistent smaller radius
                                pointHoverRadius: 5, // Consistent smaller hover radius
                                tension: 0.1,
                                fill: false, // Don't fill the area, just show colored points
                                showLine: false, // Remove connecting lines
                                order: 10 // Put sensor data behind event markers
                            });
                            
                            // Set min/max on x-axis with a small margin
                            if (dataPoints.length > 0) {
                                const sortedPoints = [...dataPoints].sort((a, b) => a.x - b.x);
                                
                                // If we have actual data points, use those for min/max
                                // but ensure they're within the requested range
                                const dataMin = Math.max(startDateMs, sortedPoints[0].x);
                                const dataMax = Math.min(endDateMs, sortedPoints[sortedPoints.length - 1].x);
                                
                                // Use the full time range to ensure consistent x-axis
                                chart.options.scales.x.min = startDateMs;
                                chart.options.scales.x.max = endDateMs;
                            } else {
                                // If no data points, use the full requested range
                                chart.options.scales.x.min = startDateMs;
                                chart.options.scales.x.max = endDateMs;
                            }
                        } else {
                            // Use the full time range even with no data
                            chart.options.scales.x.min = startDateMs;
                            chart.options.scales.x.max = endDateMs;
                        }
                    } else {
                        // Individual sensor mode
                        // Group data by sensor
                        const sensorGroups = {};
                        // Build a map of all timestamps (bins) and sensors in data (declare once)
                        const allTimestamps = Array.from(new Set(data.map(item => item.timestamp))).sort();
                        const sensorsInData = Array.from(new Set(data.map(item => item.sensorId)));
                        // Group data by sensor, including nulls
                        sensorsInData.forEach(sensorId => {
                            sensorGroups[sensorId] = [];
                            allTimestamps.forEach(ts => {
                                const found = data.find(item => item.sensorId === sensorId && item.timestamp === ts);
                                sensorGroups[sensorId].push({
                                    x: new Date(ts).valueOf(),
                                    y: found ? found.value : null
                                });
                            });
                        });
                        
                        // Calculate overall min/max for better scaling
                        let allValues = [];
                        let allXValues = [];
                        Object.values(sensorGroups).forEach(points => {
                            allValues = allValues.concat(points.map(p => p.y));
                            allXValues = allXValues.concat(points.map(p => p.x));
                        });
                        // Filter out nulls for min/max calculation
                        const validValues = allValues.filter(v => v !== null && v !== undefined && !isNaN(v));
                        if (validValues.length > 0) {
                            const min = Math.min(...validValues);
                            const max = Math.max(...validValues);
                            const padding = (max - min) * 0.1;
                            
                            // Update y-axis scale with padding
                            chart.options.scales.y.min = type === 'humidity' ? Math.max(0, min - padding) : Math.max(50, min - padding);
                            chart.options.scales.y.max = type === 'humidity' ? Math.min(100, max + padding) : max + padding;
                            
                            // Add a small margin for better display
                            // But still use the full time range
                            chart.options.scales.x.min = startDateMs;
                            chart.options.scales.x.max = endDateMs;
                        } else {
                            // Use the full time range even with no data
                            chart.options.scales.x.min = startDateMs;
                            chart.options.scales.x.max = endDateMs;
                        }
                        
                        // Create datasets for each sensor
                        Object.keys(sensorGroups).forEach((sensorId, index) => {
                            const sensor = availableSensors.find(s => s.address === sensorId) || 
                                        { name: `Sensor ${sensorId}`, type: 'unknown' };
                            // Use red shades for temperature, blue for humidity
                            let colorIndex = index;
                            let color;
                            if (type === 'temperature') {
                                color = tempColors[colorIndex % tempColors.length];
                            } else {
                                color = humidColors[colorIndex % humidColors.length];
                            }
                            // Sort data points by timestamp
                            const sortedData = sensorGroups[sensorId].sort((a, b) => a.x - b.x);
                            
                            // Create point colors based on values
                            const pointColors = createPointColors(sortedData, type);
                            
                            chart.data.datasets.push({
                                label: `${sensor.name || `${sensor.type} ${sensor.address}`}${type === 'temperature' ? ' Temperature (째F)' : ' Humidity (%)'}`,
                                data: sortedData,
                                borderColor: color.border, // Keep sensor-specific border color for lines
                                backgroundColor: 'transparent', // Transparent background for hollow rings
                                pointBackgroundColor: 'transparent', // Hollow points
                                pointBorderColor: pointColors, // Border color matches value-based colors
                                pointBorderWidth: 2, // Thicker border for visibility
                                pointRadius: 3, // Consistent smaller radius
                                pointHoverRadius: 5, // Consistent smaller hover radius
                                showLine: false, // Remove connecting lines
                                fill: false,
                                order: 10 // Put sensor data behind event markers
                            });
                        });
                    }
                    
                    // Fetch and add event data as separate datasets
                    fetchEventData(startDateMs, endDateMs, type).then(events => {
                        // Safety check - ensure chart still exists
                        if (!chart || !chart.data || !chart.data.datasets) {
                            console.warn(`Chart no longer exists for ${type}, skipping event data`);
                            return;
                        }
                        
                        if (events.length > 0) {
                            console.log(`Adding ${events.length} event markers to ${type} chart`);
                            
                            // Get all sensor data for interpolation
                            let allSensorData = [];
                            chart.data.datasets.forEach(dataset => {
                                if (!dataset.label.includes('Event')) {
                                    allSensorData = allSensorData.concat(dataset.data);
                                }
                            });
                            
                            // Interpolate Y values for events that need it
                            events.forEach(event => {
                                if (event.y === null) {
                                    event.y = interpolateEventValue(event.x, allSensorData, type);
                                }
                            });
                            
                            // Group events by type for different styling
                            const eventGroups = {
                                trigger: events.filter(e => e.eventType === 'trigger'),
                                configured: events.filter(e => e.eventType === 'configured'),
                                threshold: events.filter(e => e.eventType === 'threshold'),
                                error: events.filter(e => e.eventType === 'error')
                            };
                            
                            // Add event datasets with triangle styling for better visibility
                            if (eventGroups.trigger.length > 0) {
                                chart.data.datasets.push({
                                    label: 'Event Triggers',
                                    data: eventGroups.trigger,
                                    borderColor: '#000000', // Black outline
                                    backgroundColor: '#22c55e',
                                    pointBackgroundColor: '#22c55e',
                                    pointBorderColor: '#000000', // Black outline
                                    pointBorderWidth: 2,
                                    pointRadius: 6, // Increased from 4 to 6
                                    pointHoverRadius: 8, // Increased from 6 to 8
                                    pointStyle: 'triangle',
                                    showLine: false,
                                    fill: false,
                                    order: 1 // Show on top
                                });
                            }
                            
                            if (eventGroups.configured.length > 0) {
                                chart.data.datasets.push({
                                    label: 'Configured Events',
                                    data: eventGroups.configured,
                                    borderColor: '#000000', // Black outline
                                    backgroundColor: '#8b5cf6',
                                    pointBackgroundColor: '#8b5cf6',
                                    pointBorderColor: '#000000', // Black outline
                                    pointBorderWidth: 2,
                                    pointRadius: 6, // Increased from 4 to 6
                                    pointHoverRadius: 8, // Increased from 6 to 8
                                    pointStyle: 'triangle',
                                    showLine: false,
                                    fill: false,
                                    order: 1 // Show on top
                                });
                            }
                            
                            if (eventGroups.threshold.length > 0) {
                                chart.data.datasets.push({
                                    label: 'Threshold Events',
                                    data: eventGroups.threshold,
                                    borderColor: '#000000', // Black outline
                                    backgroundColor: '#f97316',
                                    pointBackgroundColor: '#f97316',
                                    pointBorderColor: '#000000', // Black outline
                                    pointBorderWidth: 2,
                                    pointRadius: 6, // Increased from 4 to 6
                                    pointHoverRadius: 8, // Increased from 6 to 8
                                    pointStyle: 'triangle',
                                    showLine: false,
                                    fill: false,
                                    order: 1 // Show on top
                                });
                            }
                            
                            if (eventGroups.error.length > 0) {
                                chart.data.datasets.push({
                                    label: 'Error Logs',
                                    data: eventGroups.error,
                                    borderColor: '#000000', // Black outline
                                    backgroundColor: '#ef4444',
                                    pointBackgroundColor: '#ef4444',
                                    pointBorderColor: '#000000', // Black outline
                                    pointBorderWidth: 2,
                                    pointRadius: 6, // Increased from 4 to 6
                                    pointHoverRadius: 8, // Increased from 6 to 8
                                    pointStyle: 'triangle',
                                    showLine: false,
                                    fill: false,
                                    order: 1 // Show on top
                                });
                            }
                        }
                        
                        // Update time reference lines
                        if (chart && chart.options && chart.options.plugins && chart.options.plugins.annotation) {
                            chart.options.plugins.annotation.annotations = generateTimeReferenceLines(startDateMs, endDateMs);
                        }
                        
                        // Update the chart with event data
                        if (chart && chart.update) {
                            chart.update('none');
                        }
                    }).catch(error => {
                        console.log('Error adding event data:', error);
                        // Still update the chart even if events fail
                        
                        // Update time reference lines even if events fail
                        if (chart && chart.options && chart.options.plugins && chart.options.plugins.annotation) {
                            chart.options.plugins.annotation.annotations = generateTimeReferenceLines(startDateMs, endDateMs);
                        }
                        
                        if (chart && chart.update) {
                            chart.update('none');
                        }
                    });
                })
                .catch(error => {
                    console.error(`Error fetching ${type} data:`, error);
                    
                    // Clear the chart area and show error
                    const canvasId = type === 'temperature' ? 'tempChart' : 'humidityChart';
                    const canvas = document.getElementById(canvasId);
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#e8e6e3';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Error loading data: ${error.message}`, canvas.width / 2, canvas.height / 2);
                });
        }

        function updateCharts() {
            const points = document.getElementById('points').value;
            
            // Use current time navigation state
            const startDate = currentStartTime.toISOString();
            const endDate = currentEndTime.toISOString();
            const timeRangeMs = currentEndTime.getTime() - currentStartTime.getTime();
            const timeRangeHours = timeRangeMs / (1000 * 60 * 60);
            
            console.log(`Updating charts for timeRange: ${timeRangeHours} hours, points: ${points}, live mode: ${isLiveMode}`);
            console.log(`Time range: ${startDate} to ${endDate}`);

            // Create URLs for API calls
            const tempUrl = new URL('/api/readings/binned', window.location.origin);
            tempUrl.searchParams.set('startDate', startDate);
            tempUrl.searchParams.set('hours', timeRangeHours);
            tempUrl.searchParams.set('points', points);
            tempUrl.searchParams.set('type', 'temperature');
            
            const humidityUrl = new URL('/api/readings/binned', window.location.origin);
            humidityUrl.searchParams.set('startDate', startDate);
            humidityUrl.searchParams.set('hours', timeRangeHours);
            humidityUrl.searchParams.set('points', points);
            humidityUrl.searchParams.set('type', 'humidity');
            
            // Fetch and update both charts
            fetchAndUpdateChart(tempUrl, 'temperature', timeRangeHours, currentStartTime.getTime(), currentEndTime.getTime());
            fetchAndUpdateChart(humidityUrl, 'humidity', timeRangeHours, currentStartTime.getTime(), currentEndTime.getTime());
        }

        // Debounced version of updateCharts for performance
        function debouncedUpdateCharts() {
            const now = Date.now();
            
            // Clear existing timeout
            if (updateChartsTimeout) {
                clearTimeout(updateChartsTimeout);
            }
            
            // If enough time has passed since last update, update immediately
            if (now - lastUpdateTime > UPDATE_DEBOUNCE_MS) {
                lastUpdateTime = now;
                updateCharts();
            } else {
                // Otherwise, schedule an update
                updateChartsTimeout = setTimeout(() => {
                    lastUpdateTime = Date.now();
                    updateCharts();
                }, UPDATE_DEBOUNCE_MS);
            }
        }

        // Custom initialization for this page
        function customInit() {
            console.log('Initializing graph page...');
            
            // Register Chart.js annotations plugin for time reference lines
        if (typeof window.ChartAnnotation !== 'undefined') {
            Chart.register(window.ChartAnnotation);
            console.log('Chart.js annotations plugin registered for time reference lines');
        } else if (typeof window['chartjs-plugin-annotation'] !== 'undefined') {
            Chart.register(window['chartjs-plugin-annotation']);
            console.log('Chart.js annotations plugin registered via direct access');
        }
            
            // Set default global options for Chart.js time axis
            Chart.defaults.scales.time.parser = function(value) {
                // Parse timestamp values (either number or string)
                if (typeof value === 'number') {
                    return value;
                } else if (typeof value === 'string') {
                    return new Date(value).valueOf();
                } else {
                    return value; // For Date objects
                }
            };
            
            // Initial update
            updateTime();
            setInterval(updateTime, 1000);
            
            // Initialize showAverage button text
            document.getElementById('averageSensors').textContent = showAverage ? 'Show Individual' : 'Show Average';
            
            // Fetch available sensors
            fetchSensors();

            // Add click handlers for buttons
            document.getElementById('averageSensors').addEventListener('click', () => {
                console.log('Average button clicked');
                toggleAverageMode();
            });
            
            // Add event listener for update colors button
            document.getElementById('updateColorsButton').addEventListener('click', () => {
                console.log('Update Colors button clicked');
                updateColorSettings();
            });
            
            // Add time control button event listeners
            document.getElementById('startDayMinusBtn').addEventListener('click', () => {
                adjustStartTime(-24);
            });
            
            document.getElementById('startHourMinusBtn').addEventListener('click', () => {
                adjustStartTime(-1);
            });
            
            document.getElementById('startHourPlusBtn').addEventListener('click', () => {
                adjustStartTime(1);
            });
            
            document.getElementById('startDayPlusBtn').addEventListener('click', () => {
                adjustStartTime(24);
            });
            
            document.getElementById('endDayMinusBtn').addEventListener('click', () => {
                adjustEndTime(-24);
            });
            
            document.getElementById('endHourMinusBtn').addEventListener('click', () => {
                adjustEndTime(-1);
            });
            
            document.getElementById('endHourPlusBtn').addEventListener('click', () => {
                adjustEndTime(1);
            });
            
            document.getElementById('endDayPlusBtn').addEventListener('click', () => {
                adjustEndTime(24);
            });
            
            // Add event listener for points dropdown to auto-update charts
            document.getElementById('points').addEventListener('change', () => {
                console.log('Points value changed, updating charts');
                debouncedUpdateCharts();
            });
            
            // Add event listener for Go Live button
            document.getElementById('goLiveBtn').addEventListener('click', () => {
                console.log('Go Live button clicked');
                goLive();
            });
            
            // Set up live data streaming (update every 10 seconds when in live mode)
            setInterval(() => {
                if (isLiveMode) {
                    // Update end time to current time
                    const now = new Date();
                    currentEndTime = new Date(now);
                    // Keep the same time range by updating start time too
                    currentStartTime = new Date(now.getTime() - (timeRangeHours * 60 * 60 * 1000));
                    
                    // Ensure timeRangeHours is properly maintained (should stay the same in live mode)
                    const calculatedRangeMs = currentEndTime.getTime() - currentStartTime.getTime();
                    const calculatedRangeHours = calculatedRangeMs / (1000 * 60 * 60);
                    
                    console.log('Live mode update:', {
                        start: currentStartTime.toISOString(),
                        end: currentEndTime.toISOString(),
                        rangeHours: timeRangeHours,
                        calculatedRangeHours: calculatedRangeHours
                    });
                    
                    updateTimeDisplay();
                    updateNavigationButtons();
                    updateGoLiveButton();
                    debouncedUpdateCharts();
                }
            }, 10000);
            
            // Set up color input synchronization
            syncColorInputs('tempLowColor', 'tempLowColorHex');
            syncColorInputs('tempMidColor', 'tempMidColorHex');
            syncColorInputs('tempHighColor', 'tempHighColorHex');
            syncColorInputs('humidLowColor', 'humidLowColorHex');
            syncColorInputs('humidMidColor', 'humidMidColorHex');
            syncColorInputs('humidHighColor', 'humidHighColorHex');
            
            // Set up event marker visibility controls
            document.getElementById('showEventTriggers').addEventListener('change', function() {
                eventSettings.showEventTriggers = this.checked;
                console.log('Event triggers visibility changed:', this.checked);
                debouncedUpdateCharts();
            });
            
            document.getElementById('showConfiguredEvents').addEventListener('change', function() {
                eventSettings.showConfiguredEvents = this.checked;
                console.log('Configured events visibility changed:', this.checked);
                debouncedUpdateCharts();
            });
            
            document.getElementById('showThresholdEvents').addEventListener('change', function() {
                eventSettings.showThresholdEvents = this.checked;
                console.log('Threshold events visibility changed:', this.checked);
                debouncedUpdateCharts();
            });
            
            document.getElementById('showErrorLogs').addEventListener('change', function() {
                eventSettings.showErrorLogs = this.checked;
                console.log('Error logs visibility changed:', this.checked);
                debouncedUpdateCharts();
            });
            
            // Add refresh events button
            document.getElementById('refreshEventsButton').addEventListener('click', () => {
                console.log('Refresh events button clicked');
                debouncedUpdateCharts();
            });
            
            // Request timezone
            socket.emit('getTimezone');
            
            // Initialize time navigation
            initializeTimeNavigation();
            
            // Initialize Go Live button state
            updateGoLiveButton();
            
            // Load initial chart data
            updateCharts();
            
            console.log('Graph page initialized');
        }

        // Initialize the application
        initializeApp(socket, customInit);
    </script>
</body>
</html> 