<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PWM Control</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="/assets/js/core.js"></script>
</head>
<body class="normal-state pwm-page" style="background-image: url('/assets/backgrounds/undergrowth_logo.png') !important; background-repeat: no-repeat !important; background-position: top center !important; background-size: 90vh auto !important; background-attachment: fixed !important;">
    <div class="container">
        <!-- Header with title, clock, mode toggle, and emergency stop -->
        <div class="header-row">
            <h2 class="header-title">PWM Control</h2>
            <div class="clock" id="clock">00:00:00</div>
            <div class="toggle-container">
                <span class="mode-label">manual</span>
                <label class="toggle pwm-mode-toggle">
                    <input type="checkbox" id="modeToggle">
                    <span class="slider pwm-mode-slider"></span>
                </label>
                <span class="mode-label">automatic</span>
                <button class="emergency-button" id="emergencyButton">Emergency Stop</button>
            </div>
        </div>

        <!-- ============= SCHEDULE SECTION ============= -->
        

        
        <!-- Active Events List -->
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]">Active Events</h2>
        </div>
        <div id="eventList">
            <!-- Events will be dynamically populated here -->
        </div>

        <!-- ============= MANUAL PWM CONTROL SECTION ============= -->
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]">Manual PWM Control</h2>
        </div>

        <div id="pwmContainer">
            <!-- PWM controls will be populated dynamically -->
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentTimezone = 'America/Los_Angeles';
        let currentEvents = [];
        
        // ==== SHARED FUNCTIONALITY ====
        
        // Define custom handler for initial state data
        function onInitialState(data) {
            if (data) {
                // Update mode toggle
                const modeToggle = document.getElementById('modeToggle');
                if (modeToggle && data.mode !== undefined) {
                    modeToggle.checked = data.mode === 0; // 0 is automatic
                }
                
                // Update the UI if there's event data
                if (data.events) {
                    updateEventDisplay(data.events);
                }
            }
        }

        // Handle state updates
        socket.on('stateUpdate', (data) => {
            console.log('Received state update:', data);
            // Update mode toggle
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle && data.mode !== undefined) {
                modeToggle.checked = data.mode === 0; // 0 is automatic
            }
            
            // Update UI if there's event data
            updateUI(data);
        });

        // Handle mode updates
        socket.on('modeUpdate', (data) => {
            console.log('Received mode update:', data);
            
            // Update mode toggle UI
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle && data.mode !== undefined) {
                modeToggle.checked = data.mode === 0; // 0 is automatic, 1 is manual
            }
        });

        // Handle timezone updates
        socket.on('timezoneUpdate', (data) => {
            const { timezone } = data;
            currentTimezone = timezone;
            updateClock();
        });
        
        // ==== SCHEDULE FUNCTIONALITY ====
        

        
        // Clock and timezone handling
        function updateClock() {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const timeString = formatter.format(now);
            const timezoneAbbr = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                timeZoneName: 'short'
            }).formatToParts(now).find(part => part.type === 'timeZoneName').value;
            
            const clockElement = document.getElementById('clock');
            if (clockElement) {
                clockElement.textContent = `${timeString} (${timezoneAbbr})`;
            }
        }

        // Countdown timer functionality
        function updateCountdown(index, triggerTime) {
            const countdownElement = document.getElementById(`countdown-${index}`);
            if (!countdownElement) return;

            // Get current time in the database timezone
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const currentLocalTime = formatter.format(now);
            
            // Parse trigger time and current time
            const [triggerHours, triggerMinutes, triggerSeconds] = triggerTime.split(':').map(Number);
            const [currentHours, currentMinutes, currentSeconds] = currentLocalTime.split(':').map(Number);
            
            // Create Date objects for today in the database timezone
            const today = new Date();
            const target = new Date(today.getFullYear(), today.getMonth(), today.getDate(), triggerHours, triggerMinutes, triggerSeconds);
            const current = new Date(today.getFullYear(), today.getMonth(), today.getDate(), currentHours, currentMinutes, currentSeconds);

            // If target time has passed today, set it for tomorrow
            if (target <= current) {
                target.setDate(target.getDate() + 1);
            }

            const diff = target - current;
            const h = Math.floor(diff / 3600000);
            const m = Math.floor((diff % 3600000) / 60000);
            const s = Math.floor((diff % 60000) / 1000);

            countdownElement.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function updateAllCountdowns() {
            const events = document.querySelectorAll('.event-item');
            const now = new Date();
            const currentTime = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();

            // Find active events for each GPIO, only considering enabled time-based events
            const activeTimeEvents = {};
            events.forEach(event => {
                // Only process time-based events for countdown logic
                const eventTimeElement = event.querySelector('.event-time');
                if (!eventTimeElement) return; // Skip non-time events
                
                const time = eventTimeElement.textContent;
                const [hours, minutes, seconds] = time.split(':').map(Number);
                const eventTime = hours * 3600 + minutes * 60 + seconds;
                const gpio = event.querySelector('.event-gpio').textContent.replace('GPIO', '');
                const enabledInput = event.querySelector('.event-enabled input');
                const isEnabled = enabledInput ? enabledInput.checked : false;
                
                if (!isEnabled) return; // Skip disabled events
                
                if (!activeTimeEvents[gpio] || 
                    (eventTime <= currentTime && eventTime > (activeTimeEvents[gpio].time || -1)) ||
                    (eventTime > currentTime && eventTime < (activeTimeEvents[gpio].time || Infinity))) {
                    activeTimeEvents[gpio] = {
                        time: eventTime,
                        event: event
                    };
                }
            });

            // Check if any threshold events are currently active (have live indicators from updateEventDisplay)
            const activeThresholdEvents = {};
            events.forEach(event => {
                const eventTimeElement = event.querySelector('.event-time');
                if (eventTimeElement) return; // Skip time events
                
                const existingLiveIndicator = event.querySelector('.live-indicator');
                if (existingLiveIndicator) {
                    const gpio = event.querySelector('.event-gpio').textContent.replace('GPIO', '');
                    activeThresholdEvents[gpio] = true;
                }
            });

            // Update active states and live indicators for time-based events
            // BUT only if no threshold event is active for that GPIO
            events.forEach(event => {
                const eventTimeElement = event.querySelector('.event-time');
                if (!eventTimeElement) return; // Skip non-time events
                
                const gpio = event.querySelector('.event-gpio').textContent.replace('GPIO', '');
                const isTimeEventActive = activeTimeEvents[gpio] && activeTimeEvents[gpio].event === event;
                const hasActiveThresholdEvent = activeThresholdEvents[gpio];
                
                // Only show as active if this time event is active AND no threshold event is overriding it
                const shouldBeActive = isTimeEventActive && !hasActiveThresholdEvent;
                event.classList.toggle('active', shouldBeActive);
                
                // Update live indicator - only add if no threshold event is active for this GPIO
                const existingLiveIndicator = event.querySelector('.live-indicator');
                if (shouldBeActive && !existingLiveIndicator) {
                    // Add live indicator if this event is now active and no threshold override
                    const liveIndicator = document.createElement('span');
                    liveIndicator.className = 'live-indicator';
                    liveIndicator.innerHTML = 'Live <span class="live-dot"></span>';
                    
                    // Insert before the toggle switch
                    const toggleElement = event.querySelector('.event-enabled');
                    if (toggleElement) {
                        event.insertBefore(liveIndicator, toggleElement);
                    }
                } else if (!shouldBeActive && existingLiveIndicator) {
                    // Remove live indicator if this event is no longer active or threshold override
                    existingLiveIndicator.remove();
                }
            });

            // Update countdowns for time-based events only
            events.forEach(event => {
                const eventTimeElement = event.querySelector('.event-time');
                if (!eventTimeElement) return; // Skip non-time events
                
                const eventId = event.dataset.index || event.querySelector('[data-event-id]')?.dataset.eventId;
                if (eventId) {
                    const time = eventTimeElement.textContent;
                    updateCountdown(eventId, time);
                }
            });
        }
        
        // Update countdowns every second
        setInterval(updateAllCountdowns, 1000);
        
        // Handle events update
        socket.on('eventsUpdated', (events) => {
            console.log('Events updated, refreshing display');
            
            // Only update if the events have actually changed
            if (JSON.stringify(events) !== JSON.stringify(currentEvents)) {
                updateEventDisplay(events);
            } else {
                console.log('Events unchanged, skipping display update');
            }
        });

        // Event handling functions
        function validateTime(timeStr) {
            // Check format
            if (!/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) {
                alert('Time must be in HH:MM:SS format');
                return false;
            }

            const [hours, minutes, seconds] = timeStr.split(':').map(Number);

            // Check ranges
            if (hours < 0 || hours > 23) {
                alert('Hours must be between 00 and 23');
                return false;
            }
            if (minutes < 0 || minutes > 59) {
                alert('Minutes must be between 00 and 59');
                return false;
            }
            if (seconds < 0 || seconds > 59) {
                alert('Seconds must be between 00 and 59');
                return false;
            }

            return true;
        }

        function validatePwm(pwm) {
            const pwmNum = Number(pwm);
            if (isNaN(pwmNum) || pwmNum < 0 || pwmNum > 1023) {
                alert('PWM value must be between 0 and 1023');
                return false;
            }
            return true;
        }

        // Convert local time string (HH:MM:SS) to UTC time string (HH:MM:SS)
        function convertLocalToUTC(timeStr) {
            // Parse the time string
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            
            // Create a Date object for today with the specified time in the database timezone
            const now = new Date();
            const localDate = new Date(
                now.getFullYear(), 
                now.getMonth(), 
                now.getDate(), 
                hours, 
                minutes, 
                seconds
            );
            
            // Get the UTC hours, minutes, seconds
            const utcHours = localDate.getUTCHours();
            const utcMinutes = localDate.getUTCMinutes();
            const utcSeconds = localDate.getUTCSeconds();
            
            // Format as HH:MM:SS
            return `${utcHours.toString().padStart(2, '0')}:${utcMinutes.toString().padStart(2, '0')}:${utcSeconds.toString().padStart(2, '0')}`;
        }

        // Convert UTC time string (HH:MM:SS) to local time string (HH:MM:SS) in database timezone
        function convertUTCToLocal(timeStr) {
            // Parse the time string
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            
            // Create a Date object for today at the UTC time
            const now = new Date();
            const utcDate = new Date(Date.UTC(
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate(),
                hours,
                minutes,
                seconds
            ));
            
            // Format the date to the database timezone
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            
            return formatter.format(utcDate);
        }


        
        function updateEventDisplay(events) {
            currentEvents = events || []; // Store for real-time updates
            const eventList = document.getElementById('eventList');
            eventList.innerHTML = '';
            
            // Add empty reference div at the top
            const referenceDiv = document.createElement('div');
            referenceDiv.className = 'event-item';
            referenceDiv.innerHTML = `
                <select id="newEventGpio" class="event-gpio" style="background: #604331; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.3rem; width: auto;">
                    <option value="" style="color: white;">GPIO</option>
                    <option value="12" style="color: #ffeb3b;">GPIO12</option>
                    <option value="13" style="color: #2196f3;">GPIO13</option>
                    <option value="18" style="color: #c0110b;">GPIO18</option>
                    <option value="19" style="color: #45a049;">GPIO19</option>
                </select>
                
                <select id="newEventPriority" class="event-priority" style="background: #4B0082; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.3rem; width: auto; text-align: center;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
                
                <select id="newEventType" class="event-type" style="background: #21374a; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.3rem; width: auto;">
                    <option value="">Trigger</option>
                    <option value="time" style="color: #2196f3;">Time</option>
                    <option value="temperature" style="color: #c0110b;">Temperature</option>
                    <option value="humidity" style="color: #2196f3;">Humidity</option>
                </select>
                
                <select id="newEventSensor" class="event-sensor" style="background: #4d332a; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.3rem; width: auto; display: none;">
                    <option value="">Sensor</option>
                    <option value="0x38">0x38</option>
                    <option value="0x39">0x39</option>
                </select>
                
                <select id="newEventCondition" class="event-threshold" style="background: #352441; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.3rem; width: auto; display: none;">
                    <option value="">Cond</option>
                    <option value="greater_than">></option>
                    <option value="less_than"><</option>
                </select>
                
                <input type="text" id="newEventValue" placeholder="HH:MM:SS" class="event-threshold" style="background: #273827; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.2rem; width: 100px; text-align: center; display: none;">
                
                <input type="number" id="newEventCooldown" placeholder="5" min="1" max="60" class="cooldown" style="background: #402c2b; color: white; border: none; border-radius: 0.25rem; padding: 0.1rem 0.3rem; width: 50px; text-align: center; display: none;">
                
                <span class="event-pwm" style="background: #604331; color: white; border-radius: 0.25rem; padding: 0.1rem 0.3rem; min-width: 120px; display: flex; align-items: center; gap: 0.3rem;">
                    <input type="number" id="newEventPwm" placeholder="0-1023" min="0" max="1023" style="width: 100px; background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white; border-radius: 0.25rem; padding: 0.1rem; text-align: center;">
                    <span id="newEventPercent" style="font-size: 1.2rem;">0%</span>
                </span>
                
                <label class="toggle event-enabled" style="min-width: 60px; display: flex; justify-content: center;">
                    <input type="checkbox" id="newEventEnabled" checked>
                    <span class="slider"></span>
                </label>
                
                <button id="addEventBtn" class="delete" style="background: var(--success-color); min-width: 90px;">
                    Add
                </button>
            `;
            eventList.appendChild(referenceDiv);
            
            // Add event handlers for the new event form
            setupNewEventForm();
            
            if (!events || events.length === 0) {
                const noEventsDiv = document.createElement('div');
                noEventsDiv.className = 'no-events';
                noEventsDiv.textContent = 'No events configured';
                eventList.appendChild(noEventsDiv);
                return;
            }
            
            // Sort events: threshold events first (by priority), then time events (chronologically)
            const sortedEvents = [...events].sort((a, b) => {
                const aIsTime = a.trigger_type === 'time' || !a.trigger_type;
                const bIsTime = b.trigger_type === 'time' || !b.trigger_type;
                
                // If both are threshold events, sort by priority (lower number = higher priority)
                if (!aIsTime && !bIsTime) {
                    const aPriority = a.priority || 1;
                    const bPriority = b.priority || 1;
                    if (aPriority !== bPriority) {
                        return aPriority - bPriority;
                    }
                    // If same priority, sort by GPIO
                    return a.gpio - b.gpio;
                }
                
                // If both are time events, sort chronologically
                if (aIsTime && bIsTime) {
                    // Convert times to local timezone for proper sorting
                    const aLocalTime = convertUTCToLocal(a.time);
                    const bLocalTime = convertUTCToLocal(b.time);
                    return aLocalTime.localeCompare(bLocalTime);
                }
                
                // Threshold events come first, then time events
                return aIsTime ? 1 : -1;
            });
            
            // Get current time in local timezone for proper comparison
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const currentLocalTime = formatter.format(now);
            const [currentHours, currentMinutes, currentSeconds] = currentLocalTime.split(':').map(Number);
            const currentTimeSeconds = currentHours * 3600 + currentMinutes * 60 + currentSeconds;
            
            // Process time-based events for active detection
            const timeEvents = sortedEvents.filter(e => e.trigger_type === 'time' || !e.trigger_type);
            const eventsWithLocalTime = timeEvents.map(event => {
                const localTimeStr = convertUTCToLocal(event.time);
                const [localHours, localMinutes, localSeconds] = localTimeStr.split(':').map(Number);
                const localTimeSeconds = localHours * 3600 + localMinutes * 60 + localSeconds;
                
                return { ...event, localTimeStr, localTimeSeconds };
            });
            
            // Find active time-based events (only the most recent past event for each GPIO)
            // Future events should not show as "Live" - they only show countdown timers
            const activeTimeEvents = {};
            eventsWithLocalTime.forEach(event => {
                if (!event.enabled) return;
                
                const gpio = event.gpio;
                const eventTime = event.localTimeSeconds;
                
                // Only consider past events (or events happening right now) as "active"
                if (eventTime <= currentTimeSeconds) {
                    // This is a past event - check if it's the most recent for this GPIO
                    if (!activeTimeEvents[gpio] || eventTime > activeTimeEvents[gpio].time) {
                        activeTimeEvents[gpio] = { time: eventTime, event: event };
                    }
                }
                // Future events are ignored for "Live" indicator - they only show countdown
            });
            
            // Group events by GPIO to determine which should show "Live"
            const eventsByGpio = {};
            sortedEvents.forEach(event => {
                if (!eventsByGpio[event.gpio]) {
                    eventsByGpio[event.gpio] = [];
                }
                eventsByGpio[event.gpio].push(event);
            });
            
            // Determine the active event for each GPIO (highest priority)
            const activeEventsByGpio = {};
            Object.keys(eventsByGpio).forEach(gpio => {
                const gpioEvents = eventsByGpio[gpio].filter(e => e.enabled); // Only consider enabled events
                let activeEvent = null;
                
                // First, find active time-based events
                let activeTimeEvent = null;
                gpioEvents.forEach(event => {
                    if (event.trigger_type === 'time' || !event.trigger_type) {
                        // Time-based event logic - show Live on the controlling event
                        const isEventActive = activeTimeEvents[event.gpio] && 
                                             activeTimeEvents[event.gpio].event.id === event.id;
                        if (isEventActive) {
                            activeTimeEvent = event;
                        }
                    }
                });
                
                // Then, find active threshold-based events
                let activeThresholdEvent = null;
                gpioEvents.forEach(event => {
                    if (event.trigger_type !== 'time' && event.trigger_type) {
                        // Threshold-based event logic - check if event is currently triggered and active
                        if (event.last_triggered_at && event.duration_seconds) {
                            const lastTriggered = new Date(event.last_triggered_at);
                            const durationMs = (event.duration_seconds || 30) * 1000;
                            const expiresAt = lastTriggered.getTime() + durationMs;
                            const isEventActive = Date.now() < expiresAt;
                            
                            if (isEventActive) {
                                const currentPriority = event.priority || 1;
                                const activePriority = activeThresholdEvent ? (activeThresholdEvent.priority || 1) : 999;
                                
                                if (!activeThresholdEvent || currentPriority < activePriority) {
                                    activeThresholdEvent = event;
                                }
                            }
                        }
                    }
                });
                
                // Apply backend priority resolution logic:
                // 1. If no time event, use threshold event
                // 2. If no threshold event, use time event  
                // 3. If both exist, compare priorities (lower number = higher priority)
                // 4. If same priority, threshold events take precedence
                if (!activeTimeEvent && activeThresholdEvent) {
                    activeEvent = activeThresholdEvent;
                } else if (activeTimeEvent && !activeThresholdEvent) {
                    activeEvent = activeTimeEvent;
                } else if (activeTimeEvent && activeThresholdEvent) {
                    const thresholdPriority = activeThresholdEvent.priority || 1;
                    const timePriority = activeTimeEvent.priority || 1;
                    
                    if (thresholdPriority < timePriority) {
                        activeEvent = activeThresholdEvent;
                    } else if (thresholdPriority === timePriority) {
                        // Same priority: threshold events take precedence during their cooldown
                        activeEvent = activeThresholdEvent;
                    } else {
                        activeEvent = activeTimeEvent;
                    }
                }
                
                if (activeEvent) {
                    activeEventsByGpio[gpio] = activeEvent.id;
                }
            });

            sortedEvents.forEach((event, index) => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'event-item';
                eventDiv.setAttribute('data-index', event.id);
                
                let triggerInfo = '';
                let statusInfo = '';
                
                if (event.trigger_type === 'time' || !event.trigger_type) {
                    // Time-based event
                    const localTimeStr = convertUTCToLocal(event.time);
                    triggerInfo = `<span class="event-time">${localTimeStr}</span>`;
                    statusInfo = `<span class="countdown" id="countdown-${event.id}">--:--:--</span>`;
                } else {
                    // Threshold-based event
                    const condition = event.threshold_condition === 'greater_than' ? 'above' : 
                                     event.threshold_condition === 'less_than' ? 'below' : 
                                     event.threshold_condition;
                    const unit = event.sensor_type === 'temperature' ? 'Â°F' : '%';
                    
                    triggerInfo = `
                        <span class="event-sensor">${event.sensor_address}</span>
                        <span class="event-threshold">${condition} ${event.threshold_value}${unit}</span>
                    `;
                    
                    // Show trigger button with cooldown timer using timestamp-based approach
                    let timeDisplay;
                    let buttonClass;
                    let buttonAction;
                    
                    const cooldownStatus = getCooldownStatus(event);
                    
                    if (cooldownStatus === 'cooldown') {
                        // Event is in cooldown - show remaining time
                        const timeLeft = getTimeLeft(event);
                        timeDisplay = formatTimeLeft(timeLeft);
                        buttonClass = 'trigger-button-cooldown';
                        buttonAction = `resetCooldown(${event.id})`;
                    } else {
                        // Event is ready - show full cooldown time
                        const totalMinutes = event.cooldown_minutes || 5;
                        if (totalMinutes >= 60) {
                            const hours = Math.floor(totalMinutes / 60);
                            const minutes = totalMinutes % 60;
                            timeDisplay = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                        } else {
                            timeDisplay = `${totalMinutes}m`;
                        }
                        buttonClass = 'trigger-button-ready';
                        buttonAction = `triggerEvent(${event.id})`;
                    }
                    
                    statusInfo = `<button class="${buttonClass}" 
                        data-event-id="${event.id}"
                        onclick="${buttonAction}">${timeDisplay}</button>`;
                }
                
                const percentage = Math.round((event.pwm_value / 1023) * 100);
                const triggerTypeDisplay = event.trigger_type || 'time';
                
                // Only show "Live" if this is the active event for this GPIO
                const isActive = activeEventsByGpio[event.gpio] === event.id;
                const liveIndicator = isActive ? '<span class="live-indicator">Live <span class="live-dot"></span></span>' : '';
                
                // Different layouts for time-based vs threshold-based events
                if (event.trigger_type === 'time' || !event.trigger_type) {
                    // Time-based events: swap PWM and countdown positions
                    eventDiv.innerHTML = `
                        <span class="event-gpio gpio-${event.gpio}">GPIO${event.gpio}</span>
                        <span class="event-priority">${event.priority || 1}</span>
                        <span class="event-type ${triggerTypeDisplay}">${triggerTypeDisplay}</span>
                        ${triggerInfo}
                        ${statusInfo}
                        <span class="event-pwm">${event.pwm_value}/1023 ${percentage}%</span>
                        ${liveIndicator}
                        <label class="toggle event-enabled">
                            <input type="checkbox" ${event.enabled ? 'checked' : ''} 
                                   onchange="toggleEvent(${event.id}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="delete" onclick="deleteEvent(${event.id})">Delete</button>
                    `;
                } else {
                    // Threshold-based events: keep original order
                    eventDiv.innerHTML = `
                        <span class="event-gpio gpio-${event.gpio}">GPIO${event.gpio}</span>
                        <span class="event-priority">${event.priority || 1}</span>
                        <span class="event-type ${triggerTypeDisplay}">${triggerTypeDisplay}</span>
                        ${triggerInfo}
                        <span class="event-pwm">${event.pwm_value}/1023 ${percentage}%</span>
                        ${statusInfo}
                        ${liveIndicator}
                        <label class="toggle event-enabled">
                            <input type="checkbox" ${event.enabled ? 'checked' : ''} 
                                   onchange="toggleEvent(${event.id}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="delete" onclick="deleteEvent(${event.id})">Delete</button>
                    `;
                }
                
                eventList.appendChild(eventDiv);
                
                // Update countdown for time-based events
                if (event.trigger_type === 'time' || !event.trigger_type) {
                    const localTimeStr = convertUTCToLocal(event.time);
                    updateCountdown(event.id, localTimeStr);
                }
            });
        }

        // Custom confirmation dialog
        function showConfirmDialog(message, onConfirm, onCancel) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #333;
                color: #e8e6e3;
                padding: 2rem;
                border-radius: 0.5rem;
                border: 1px solid #736b5e;
                max-width: 400px;
                text-align: center;
                font-family: Arial, sans-serif;
            `;
            
            dialog.innerHTML = `
                <p style="margin-bottom: 1.5rem; font-size: 1.1rem;">${message}</p>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button id="confirmYes" style="
                        padding: 0.5rem 1rem;
                        background-color: #c0110b;
                        color: white;
                        border: none;
                        border-radius: 0.25rem;
                        cursor: pointer;
                        font-size: 1rem;
                    ">Delete</button>
                    <button id="confirmNo" style="
                        padding: 0.5rem 1rem;
                        background-color: #4f5559;
                        color: white;
                        border: none;
                        border-radius: 0.25rem;
                        cursor: pointer;
                        font-size: 1rem;
                    ">Cancel</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Add event listeners
            document.getElementById('confirmYes').onclick = () => {
                document.body.removeChild(overlay);
                onConfirm();
            };
            
            document.getElementById('confirmNo').onclick = () => {
                document.body.removeChild(overlay);
                onCancel();
            };
            
            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    onCancel();
                }
            };
        }

        function deleteEvent(id) {
            console.log('deleteEvent called with id:', id); // Debug log
            console.log('Event element:', document.querySelector(`[data-index="${id}"]`)); // Debug log
            
            showConfirmDialog(
                'Are you sure you want to delete this event?',
                () => {
                    console.log('User confirmed deletion, emitting deleteEvent to server'); // Debug log
                    socket.emit('deleteEvent', { id });
                },
                () => {
                    console.log('User cancelled deletion'); // Debug log
                }
            );
        }

        function toggleEvent(id, enabled) {
            socket.emit('toggleEvent', { id, enabled });
        }

        function updateUI(data) {
            if (data.events) {
                updateEventDisplay(data.events);
            }
        }
        
        // ==== MANUAL PWM FUNCTIONALITY ====
        
        // Handle PWM state updates
        socket.on('pwmStateUpdate', (data) => {
            console.log('Received PWM state update:', data);
            updatePWMDisplay(data);
        });
        
        // Handle initial state data (includes PWM states)
        socket.on('initialState', (data) => {
            console.log('Received initial state:', data);
            if (data.pwmStates) {
                updatePWMDisplay(data.pwmStates);
            }
            // Update mode toggle if present
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle && data.mode !== undefined) {
                modeToggle.checked = data.mode === 0; // 0 is automatic
            }
        });
        
        // PWM control functions
        function setPWM(pin) {
            const input = document.getElementById(`pwm-${pin}`);
            const value = parseInt(input.value);
            
            console.log('Setting PWM value:', { pin, value });
            
            // Send to server
            socket.emit('pwmSet', { pin: pin, value: value });
        }

        function togglePWM(pin, enabled) {
            console.log('Toggling PWM:', { pin, enabled });
            socket.emit('pwmToggle', { pin, enabled });
        }

        socket.on('pwmError', (data) => {
            console.log('Received pwmError:', data);
            const { pin, message, blocked } = data;
            alert(`PWM Error (GPIO${pin}): ${message}`);
        });
        
        // Custom initialization for this page
        function customInit() {
            // Initial clock update
            updateClock();
            setInterval(updateClock, 1000);
            
            // Request timezone
            socket.emit('getTimezone');
            
            // Request events from server
            socket.emit('getEvents');
            
            // Initialize PWM display immediately to ensure it's always visible
            updatePWMDisplay({});
            
            // Request initial state (includes PWM data)
            socket.emit('getInitialState');
            
            // Set up listener for mode toggle
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle) {
                modeToggle.addEventListener('change', function() {
                    socket.emit('setMode', { automatic: this.checked });
                });
            }
            

        }
        

        
        // Initialize the application
        initializeApp(socket, customInit);

        function updatePWMDisplay(pwmStates) {
            const pwmContainer = document.getElementById('pwmContainer');
            
            // Always ensure the container exists and is visible
            if (!pwmContainer) {
                console.error('PWM container not found!');
                return;
            }
            
            // Clear existing content
            pwmContainer.innerHTML = '';
            
            // Check if we have actual data - be more flexible about data format
            const hasData = pwmStates && (
                (pwmStates.current && Object.keys(pwmStates.current).length > 0) || 
                (pwmStates.manual && Object.keys(pwmStates.manual).length > 0)
            );
            
            console.log('PWM Display Update:', { pwmStates, hasData }); // Debug log
            
            // Always show all 4 GPIO controls
            [12, 13, 18, 19].forEach(gpio => {
                const pwmDiv = document.createElement('div');
                pwmDiv.className = 'pwm-control';
                pwmDiv.dataset.gpio = gpio;
                
                if (hasData) {
                    // Use real data when available
                    const currentStates = pwmStates.current || {};
                    const manualStates = pwmStates.manual || {};
                    
                    const currentState = currentStates[gpio] || { value: 0, enabled: false };
                    const manualState = manualStates[gpio] || { value: 0, enabled: false };
                    
                    const percentage = Math.round((currentState.value / 1023) * 100);
                    
                    pwmDiv.innerHTML = `
                        <span class="gpio-title gpio-title-${gpio}">GPIO${gpio}</span>
                        <input type="number" class="pwm-input" id="pwm-${gpio}" value="${manualState.value}" min="0" max="1023" step="1">
                        <span class="event-pwm">${currentState.value}/1023 ${percentage}%</span>
                        <label class="switch pwm-toggle">
                            <input type="checkbox" ${manualState.enabled ? 'checked' : ''} 
                                   onchange="togglePWM(${gpio}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="pwm-set" onclick="setPWM(${gpio})">Set</button>
                    `;
                } else {
                    // Show loading placeholders when no data
                    pwmDiv.innerHTML = `
                        <span class="gpio-title gpio-title-${gpio}">GPIO${gpio}</span>
                        <input type="number" class="pwm-input" id="pwm-${gpio}" value="" placeholder="..." min="0" max="1023" step="1" disabled>
                        <span class="event-pwm">Loading...</span>
                        <label class="switch pwm-toggle">
                            <input type="checkbox" disabled>
                            <span class="slider"></span>
                        </label>
                        <button class="pwm-set" onclick="setPWM(${gpio})" disabled>Set</button>
                    `;
                }
                
                pwmContainer.appendChild(pwmDiv);
            });
        }



        function triggerEvent(id) {
            console.log('Manual trigger requested for event:', id);
            
            // Send trigger request - database will handle cooldown state
            socket.emit('triggerEvent', { id, triggerTime: new Date().toISOString() });
        }

        function resetCooldown(id) {
            console.log('Reset cooldown requested for event:', id);
            
            // Send reset request - database will handle cooldown state
            socket.emit('resetCooldown', { id });
        }

        // Log-based approach - no complex local state tracking needed
        
        // ==== SHARED FUNCTIONALITY ====
        
        // Simple timestamp-based cooldown calculation
        function getCooldownStatus(event) {
            if (!event.last_triggered_at) return 'ready';
            
            const triggered = new Date(event.last_triggered_at);
            const cooldownMs = (event.cooldown_minutes || 5) * 60 * 1000;
            const expiresAt = triggered.getTime() + cooldownMs;
            
            // Check if cooldown has naturally expired
            if (Date.now() >= expiresAt) return 'ready';
            
            // Check if there's a more recent 'cleared' entry that would reset the cooldown
            // Note: This is a simplified check - in a full implementation we'd query the log
            // For now, we rely on the server to update last_triggered_at or provide cleared status
            
            return 'cooldown';
        }
        
        function getTimeLeft(event) {
            if (!event.last_triggered_at) return 0;
            
            const triggered = new Date(event.last_triggered_at);
            const cooldownMs = (event.cooldown_minutes || 5) * 60 * 1000;
            const expiresAt = triggered.getTime() + cooldownMs;
            const timeLeft = expiresAt - Date.now();
            
            return Math.max(0, timeLeft);
        }
        
        function formatTimeLeft(timeLeft) {
            const totalSeconds = Math.ceil(timeLeft / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            
            if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        }

        // Real-time updates for trigger buttons
        setInterval(() => {
            currentEvents.forEach(event => {
                if (event.trigger_type !== 'time' && event.trigger_type) {
                    const button = document.querySelector(`button[data-event-id="${event.id}"]`);
                    if (!button) return;
                    
                    const cooldownStatus = getCooldownStatus(event);
                    let timeDisplay;
                    let buttonClass;
                    
                    if (cooldownStatus === 'cooldown') {
                        // Event is in cooldown - show remaining time
                        const timeLeft = getTimeLeft(event);
                        timeDisplay = formatTimeLeft(timeLeft);
                        buttonClass = 'trigger-button-cooldown';
                    } else {
                        // Event is ready - show full cooldown time
                        const totalMinutes = event.cooldown_minutes || 5;
                        if (totalMinutes >= 60) {
                            const hours = Math.floor(totalMinutes / 60);
                            const minutes = totalMinutes % 60;
                            timeDisplay = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                        } else {
                            timeDisplay = `${totalMinutes}m`;
                        }
                        buttonClass = 'trigger-button-ready';
                    }
                    
                    // Only update if state has changed
                    if (button.className !== buttonClass || button.textContent !== timeDisplay) {
                        button.textContent = timeDisplay;
                        button.className = buttonClass;
                        
                        // Set onclick properly based on button state
                        if (cooldownStatus === 'cooldown') {
                            button.onclick = () => resetCooldown(event.id);
                        } else {
                            button.onclick = () => triggerEvent(event.id);
                        }
                    }
                }
            });
        }, 1000); // Update every second

        // Setup new event form handlers
        function setupNewEventForm() {
            const typeSelect = document.getElementById('newEventType');
            const sensorSelect = document.getElementById('newEventSensor');
            const conditionSelect = document.getElementById('newEventCondition');
            const valueInput = document.getElementById('newEventValue');
            const cooldownInput = document.getElementById('newEventCooldown');
            const pwmInput = document.getElementById('newEventPwm');
            const percentSpan = document.getElementById('newEventPercent');
            const addBtn = document.getElementById('addEventBtn');
            
            // Update PWM percentage when PWM value changes
            pwmInput.addEventListener('input', function() {
                const value = parseInt(this.value) || 0;
                const percent = Math.round((value / 1023) * 100);
                percentSpan.textContent = `${percent}%`;
            });
            
            // Add time input formatting helper
            valueInput.addEventListener('input', function() {
                if (typeSelect.value === 'time') {
                    let value = this.value.replace(/[^\d:]/g, ''); // Remove non-digits and non-colons
                    
                    // Auto-format as user types
                    if (value.length === 2 && !value.includes(':')) {
                        value += ':';
                    } else if (value.length === 5 && value.split(':').length === 2) {
                        value += ':';
                    }
                    
                    // Limit to HH:MM:SS format
                    const parts = value.split(':');
                    if (parts.length > 3) {
                        value = parts.slice(0, 3).join(':');
                    }
                    
                    // Limit each part to 2 digits
                    const formattedParts = parts.map((part, index) => {
                        if (part.length > 2) {
                            return part.substring(0, 2);
                        }
                        return part;
                    });
                    
                    this.value = formattedParts.join(':');
                }
            });
            
            // Update fields visibility based on trigger type selection
            typeSelect.addEventListener('change', function() {
                const type = this.value;
                if (type === 'time') {
                    // Time events: show only value input (as text input for military time)
                    valueInput.type = 'text';
                    valueInput.placeholder = 'HH:MM:SS (24-hour)';
                    valueInput.style.display = 'inline-block';
                    sensorSelect.style.display = 'none';
                    conditionSelect.style.display = 'none';
                    cooldownInput.style.display = 'none';
                } else if (type === 'temperature' || type === 'humidity') {
                    // Threshold events: show sensor, condition, value, and cooldown
                    valueInput.type = 'number';
                    valueInput.placeholder = type === 'temperature' ? 'Â°F' : '%';
                    if (type === 'humidity') {
                        valueInput.min = '0';
                        valueInput.max = '100';
                    } else {
                        valueInput.removeAttribute('min');
                        valueInput.removeAttribute('max');
                    }
                    valueInput.style.display = 'inline-block';
                    sensorSelect.style.display = 'inline-block';
                    conditionSelect.style.display = 'inline-block';
                    cooldownInput.style.display = 'inline-block';
                } else {
                    // No trigger type selected: hide all additional fields
                    valueInput.style.display = 'none';
                    sensorSelect.style.display = 'none';
                    conditionSelect.style.display = 'none';
                    cooldownInput.style.display = 'none';
                }
            });
            
            // Add event button handler
            addBtn.addEventListener('click', function() {
                createNewEvent();
            });
        }
        
        // Create new event from form
        function createNewEvent() {
            console.log('createNewEvent function called'); // Debug log
            
            const gpio = document.getElementById('newEventGpio').value;
            const priority = document.getElementById('newEventPriority').value;
            const triggerType = document.getElementById('newEventType').value;
            const pwm = document.getElementById('newEventPwm').value;
            const enabled = document.getElementById('newEventEnabled').checked;
            
            console.log('New event form values:', { gpio, priority, triggerType, pwm, enabled }); // Debug log
            
            // Validation
            if (!gpio) {
                alert('Please select a GPIO');
                return;
            }
            
            if (!triggerType) {
                alert('Please select a trigger type');
                return;
            }
            
            if (!pwm) {
                alert('Please enter a PWM value');
                return;
            }
            
            if (!validatePwm(pwm)) {
                console.log('PWM validation failed'); // Debug log
                return;
            }
            
            let eventData = {
                gpio: parseInt(gpio),
                pwm_value: parseInt(pwm),
                enabled: enabled ? 1 : 0,
                trigger_type: triggerType,
                priority: parseInt(priority)
            };
            
            console.log('New event data prepared:', eventData); // Debug log
            
            if (triggerType === 'time') {
                // Time-based logic
                const localTime = document.getElementById('newEventValue').value;
                
                if (!localTime) {
                    alert('Please enter a time');
                    return;
                }
                
                if (!validateTime(localTime)) {
                    return;
                }
                
                // Convert the local time to UTC for storage
                const utcTime = convertLocalToUTC(localTime);
                eventData.time = utcTime;
                
                // Send to server
                socket.emit('addEvent', eventData);
            } else {
                // Threshold-based logic
                const sensorAddress = document.getElementById('newEventSensor').value;
                const thresholdOperator = document.getElementById('newEventCondition').value;
                const thresholdValue = document.getElementById('newEventValue').value;
                const cooldownMinutes = document.getElementById('newEventCooldown').value || '5';
                
                if (!sensorAddress) {
                    alert('Please select a sensor');
                    return;
                }
                
                if (!thresholdOperator) {
                    alert('Please select a condition');
                    return;
                }
                
                if (!thresholdValue) {
                    alert('Please enter a threshold value');
                    return;
                }
                
                if (isNaN(parseFloat(thresholdValue))) {
                    alert('Threshold value must be a number');
                    return;
                }
                
                eventData.trigger_type = triggerType;
                eventData.sensor_address = sensorAddress;
                eventData.sensor_type = triggerType; // 'temperature' or 'humidity'
                eventData.threshold_condition = thresholdOperator;
                eventData.threshold_value = parseFloat(thresholdValue);
                eventData.cooldown_minutes = parseInt(cooldownMinutes) || 5;
                eventData.duration_seconds = (parseInt(cooldownMinutes) || 5) * 60; // Convert minutes to seconds
                eventData.time = ''; // Empty time for threshold events
                
                console.log('Sending new threshold event to server:', eventData);
                
                // Send to server
                socket.emit('addEvent', eventData);
            }
            
            // Clear form after submission
            clearNewEventForm();
        }
        
        // Clear the new event form
        function clearNewEventForm() {
            document.getElementById('newEventGpio').value = '';
            document.getElementById('newEventPriority').value = '1';
            document.getElementById('newEventType').value = '';
            document.getElementById('newEventSensor').value = '';
            document.getElementById('newEventCondition').value = '';
            document.getElementById('newEventValue').value = '';
            document.getElementById('newEventCooldown').value = '';
            document.getElementById('newEventPwm').value = '';
            document.getElementById('newEventPercent').textContent = '0%';
            document.getElementById('newEventEnabled').checked = true;
            
            // Hide all additional fields initially
            document.getElementById('newEventSensor').style.display = 'none';
            document.getElementById('newEventCondition').style.display = 'none';
            document.getElementById('newEventValue').style.display = 'none';
            document.getElementById('newEventCooldown').style.display = 'none';
        }
    </script>
</body>
</html>