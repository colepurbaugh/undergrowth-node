<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PWM Control</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    <link rel="stylesheet" href="/assets/css/main.css">
    <script src="/assets/js/core.js"></script>
</head>
<body class="normal-state pwm-page" style="background-image: url('/assets/backgrounds/undergrowth_logo.png') !important; background-repeat: no-repeat !important; background-position: top center !important; background-size: 90vh auto !important; background-attachment: fixed !important;">
    <div class="container">
        <!-- Header with title, clock, mode toggle, and emergency stop -->
        <div class="header-row">
            <h2 class="header-title">PWM Control</h2>
            <div class="clock" id="clock">00:00:00</div>
            <div class="toggle-container">
                <span class="mode-label">manual</span>
                <label class="toggle pwm-mode-toggle">
                    <input type="checkbox" id="modeToggle">
                    <span class="slider pwm-mode-slider"></span>
                </label>
                <span class="mode-label">automatic</span>
                <button class="emergency-button" id="emergencyButton">Emergency Stop</button>
            </div>
        </div>

        <!-- ============= SCHEDULE SECTION ============= -->
        
        <!-- Add New Event Form -->
        <div class="event-control">
            <!-- Trigger Section -->
            <div class="trigger-section">
                <h3 class="section-title">Action</h3>
                
                <select id="triggerType" class="form-box trigger-box" onchange="updateEventForm()">
                    <option value="time">Trigger: Time</option>
                    <option value="temperature">Trigger: Temperature</option>
                    <option value="humidity">Trigger: Humidity</option>
                </select>
                
                <!-- Time field (shown conditionally) -->
                <input type="text" id="triggerTime" class="form-box time-box" pattern="[0-9]{2}:[0-9]{2}:[0-9]{2}" placeholder="Time: HH:MM:SS">
                
                <!-- Threshold fields (shown conditionally) -->
                <select id="sensorAddress" class="form-box sensor-box" style="display: none;">
                    <option value="0x38">Sensor: 0x38</option>
                    <option value="0x39">Sensor: 0x39</option>
                </select>
                
                <select id="thresholdOperator" class="form-box when-box" style="display: none;">
                    <option value="above">When: Above</option>
                    <option value="below">When: Below</option>
                    <option value="equals">When: Equals</option>
                </select>
                
                <div class="form-box value-box" style="display: none;">
                    <input type="number" id="thresholdValue" step="0.1" placeholder="75.0">
                    <span id="thresholdUnit">°F</span>
                </div>
                
                <div class="form-box cooldown-box" style="display: none;">
                    <span class="box-label">Cooldown:</span>
                    <input type="number" id="cooldownMinutes" min="1" max="1440" value="5">
                    <span>min</span>
                </div>
            </div>
            
            <!-- Arrow Separator -->
            <div class="arrow-separator"></div>
            
            <!-- Action Section -->
            <div class="action-section">
                <h3 class="section-title">Reaction</h3>
                
                <div class="gpio-buttons">
                    <button type="button" class="gpio-btn gpio-btn-12 selected" data-gpio="12">GPIO 12</button>
                    <button type="button" class="gpio-btn gpio-btn-13" data-gpio="13">GPIO 13</button>
                    <button type="button" class="gpio-btn gpio-btn-18" data-gpio="18">GPIO 18</button>
                    <button type="button" class="gpio-btn gpio-btn-19" data-gpio="19">GPIO 19</button>
                </div>
                
                <div class="form-box pwm-box">
                    <span class="box-label">PWM:</span>
                    <input type="number" id="pwmValue" min="0" max="1023" value="0" oninput="updatePWMPercentage()">
                    <span class="pwm-max">/1023</span>
                    <span id="pwmPercentage" class="pwm-percentage">0%</span>
                </div>
                
                <div class="form-box priority-box">
                    <span class="box-label">Priority:</span>
                    <select id="priority">
                        <option value="1">1 (Highest)</option>
                        <option value="2">2</option>
                        <option value="3" selected>3 (Lowest)</option>
                    </select>
                </div>
                
                <button class="add-event-box" onclick="addEvent()">Add Event</button>
            </div>
        </div>
        
        <!-- Active Events List -->
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]">Active Events</h2>
        </div>
        <div id="eventList">
            <!-- Events will be dynamically populated here -->
        </div>

        <!-- ============= MANUAL PWM CONTROL SECTION ============= -->
        <div class="header-row">
            <h2 class="text-xl font-semibold mb-4 text-[#e8e6e3]">Manual PWM Control</h2>
        </div>

        <div id="pwmContainer">
            <!-- PWM controls will be populated dynamically -->
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentTimezone = 'America/Los_Angeles';
        let currentEvents = [];
        
        // ==== SHARED FUNCTIONALITY ====
        
        // Define custom handler for initial state data
        function onInitialState(data) {
            if (data) {
                // Update mode toggle
                const modeToggle = document.getElementById('modeToggle');
                if (modeToggle && data.mode !== undefined) {
                    modeToggle.checked = data.mode === 0; // 0 is automatic
                }
                
                // Update the UI if there's event data
                if (data.events) {
                    updateEventDisplay(data.events);
                }
            }
        }

        // Handle state updates
        socket.on('stateUpdate', (data) => {
            console.log('Received state update:', data);
            // Update mode toggle
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle && data.mode !== undefined) {
                modeToggle.checked = data.mode === 0; // 0 is automatic
            }
            
            // Update UI if there's event data
            updateUI(data);
        });

        // Handle mode updates
        socket.on('modeUpdate', (data) => {
            console.log('Received mode update:', data);
            
            // Update mode toggle UI
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle && data.mode !== undefined) {
                modeToggle.checked = data.mode === 0; // 0 is automatic, 1 is manual
            }
        });

        // Handle timezone updates
        socket.on('timezoneUpdate', (data) => {
            const { timezone } = data;
            currentTimezone = timezone;
            updateClock();
        });
        
        // ==== SCHEDULE FUNCTIONALITY ====
        
        // NEW: Handle trigger type form switching
        function updateEventForm() {
            const triggerType = document.getElementById('triggerType').value;
            
            // Form elements
            const timeBox = document.getElementById('triggerTime');
            const sensorBox = document.getElementById('sensorAddress');
            const whenBox = document.getElementById('thresholdOperator');
            const valueBox = document.querySelector('.value-box');
            const cooldownBox = document.querySelector('.cooldown-box');
            const valueInput = document.getElementById('thresholdValue');
            const unitSpan = document.getElementById('thresholdUnit');
            
            if (triggerType === 'time') {
                // Show time field
                timeBox.style.display = 'inline-flex';
                
                // Hide threshold fields
                sensorBox.style.display = 'none';
                whenBox.style.display = 'none';
                valueBox.style.display = 'none';
                cooldownBox.style.display = 'none';
            } else {
                // Hide time field
                timeBox.style.display = 'none';
                
                // Show threshold fields
                sensorBox.style.display = 'inline-flex';
                whenBox.style.display = 'inline-flex';
                valueBox.style.display = 'inline-flex';
                cooldownBox.style.display = 'inline-flex';
                
                // Update unit and placeholder based on trigger type
                if (triggerType === 'temperature') {
                    unitSpan.textContent = '°F';
                    valueInput.placeholder = '75.0';
                } else if (triggerType === 'humidity') {
                    unitSpan.textContent = '%';
                    valueInput.placeholder = '60.0';
                }
            }
        }
        
        // Clock and timezone handling
        function updateClock() {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const timeString = formatter.format(now);
            const timezoneAbbr = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                timeZoneName: 'short'
            }).formatToParts(now).find(part => part.type === 'timeZoneName').value;
            
            const clockElement = document.getElementById('clock');
            if (clockElement) {
                clockElement.textContent = `${timeString} (${timezoneAbbr})`;
            }
        }

        // Countdown timer functionality
        function updateCountdown(index, triggerTime) {
            const countdownElement = document.getElementById(`countdown-${index}`);
            if (!countdownElement) return;

            // Get current time in the database timezone
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const currentLocalTime = formatter.format(now);
            
            // Parse trigger time and current time
            const [triggerHours, triggerMinutes, triggerSeconds] = triggerTime.split(':').map(Number);
            const [currentHours, currentMinutes, currentSeconds] = currentLocalTime.split(':').map(Number);
            
            // Create Date objects for today in the database timezone
            const today = new Date();
            const target = new Date(today.getFullYear(), today.getMonth(), today.getDate(), triggerHours, triggerMinutes, triggerSeconds);
            const current = new Date(today.getFullYear(), today.getMonth(), today.getDate(), currentHours, currentMinutes, currentSeconds);

            // If target time has passed today, set it for tomorrow
            if (target <= current) {
                target.setDate(target.getDate() + 1);
            }

            const diff = target - current;
            const h = Math.floor(diff / 3600000);
            const m = Math.floor((diff % 3600000) / 60000);
            const s = Math.floor((diff % 60000) / 1000);

            countdownElement.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function updateAllCountdowns() {
            const events = document.querySelectorAll('.event-item');
            const now = new Date();
            const currentTime = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();

            // Find active events for each GPIO, only considering enabled time-based events
            const activeEvents = {};
            events.forEach(event => {
                // Only process time-based events for countdown logic
                const eventTimeElement = event.querySelector('.event-time');
                if (!eventTimeElement) return; // Skip non-time events
                
                const time = eventTimeElement.textContent;
                const [hours, minutes, seconds] = time.split(':').map(Number);
                const eventTime = hours * 3600 + minutes * 60 + seconds;
                const gpio = event.querySelector('.event-gpio').textContent.replace('GPIO', '');
                const enabledInput = event.querySelector('.event-enabled input');
                const isEnabled = enabledInput ? enabledInput.checked : false;
                
                if (!isEnabled) return; // Skip disabled events
                
                if (!activeEvents[gpio] || 
                    (eventTime <= currentTime && eventTime > (activeEvents[gpio].time || -1)) ||
                    (eventTime > currentTime && eventTime < (activeEvents[gpio].time || Infinity))) {
                    activeEvents[gpio] = {
                        time: eventTime,
                        event: event
                    };
                }
            });

            // Update active states for time-based events only
            events.forEach(event => {
                const eventTimeElement = event.querySelector('.event-time');
                if (!eventTimeElement) return; // Skip non-time events
                
                const gpio = event.querySelector('.event-gpio').textContent.replace('GPIO', '');
                const isActive = activeEvents[gpio] && activeEvents[gpio].event === event;
                event.classList.toggle('active', isActive);
            });

            // Update countdowns for time-based events only
            events.forEach(event => {
                const eventTimeElement = event.querySelector('.event-time');
                if (!eventTimeElement) return; // Skip non-time events
                
                const eventId = event.dataset.index || event.querySelector('[data-event-id]')?.dataset.eventId;
                if (eventId) {
                    const time = eventTimeElement.textContent;
                    updateCountdown(eventId, time);
                }
            });
        }
        
        // Update countdowns every second
        setInterval(updateAllCountdowns, 1000);
        
        // Handle events update
        socket.on('eventsUpdated', (events) => {
            console.log('Events updated, refreshing display');
            
            updateEventDisplay(events);
        });

        // Event handling functions
        function validateTime(timeStr) {
            // Check format
            if (!/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) {
                alert('Time must be in HH:MM:SS format');
                return false;
            }

            const [hours, minutes, seconds] = timeStr.split(':').map(Number);

            // Check ranges
            if (hours < 0 || hours > 23) {
                alert('Hours must be between 00 and 23');
                return false;
            }
            if (minutes < 0 || minutes > 59) {
                alert('Minutes must be between 00 and 59');
                return false;
            }
            if (seconds < 0 || seconds > 59) {
                alert('Seconds must be between 00 and 59');
                return false;
            }

            return true;
        }

        function validatePwm(pwm) {
            const pwmNum = Number(pwm);
            if (isNaN(pwmNum) || pwmNum < 0 || pwmNum > 1023) {
                alert('PWM value must be between 0 and 1023');
                return false;
            }
            return true;
        }

        // Convert local time string (HH:MM:SS) to UTC time string (HH:MM:SS)
        function convertLocalToUTC(timeStr) {
            // Parse the time string
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            
            // Create a Date object for today with the specified time in the database timezone
            const now = new Date();
            const localDate = new Date(
                now.getFullYear(), 
                now.getMonth(), 
                now.getDate(), 
                hours, 
                minutes, 
                seconds
            );
            
            // Get the UTC hours, minutes, seconds
            const utcHours = localDate.getUTCHours();
            const utcMinutes = localDate.getUTCMinutes();
            const utcSeconds = localDate.getUTCSeconds();
            
            // Format as HH:MM:SS
            return `${utcHours.toString().padStart(2, '0')}:${utcMinutes.toString().padStart(2, '0')}:${utcSeconds.toString().padStart(2, '0')}`;
        }

        // Convert UTC time string (HH:MM:SS) to local time string (HH:MM:SS) in database timezone
        function convertUTCToLocal(timeStr) {
            // Parse the time string
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            
            // Create a Date object for today at the UTC time
            const now = new Date();
            const utcDate = new Date(Date.UTC(
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate(),
                hours,
                minutes,
                seconds
            ));
            
            // Format the date to the database timezone
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            
            return formatter.format(utcDate);
        }

        function addEvent() {
            console.log('addEvent function called'); // Debug log
            
            const triggerType = document.getElementById('triggerType').value;
            const gpio = document.querySelector('.gpio-btn.selected').getAttribute('data-gpio');
            const pwm = document.getElementById('pwmValue').value;
            const priority = document.getElementById('priority').value;
            
            console.log('Form values:', { triggerType, gpio, pwm, priority }); // Debug log
            
            if (!validatePwm(pwm)) {
                console.log('PWM validation failed'); // Debug log
                return;
            }
            
            let eventData = {
                gpio: parseInt(gpio),
                pwm_value: parseInt(pwm),
                enabled: 1,
                trigger_type: triggerType,
                priority: parseInt(priority)
            };
            
            console.log('Event data prepared:', eventData); // Debug log
            
            if (triggerType === 'time') {
                // Time-based logic
                const localTime = document.getElementById('triggerTime').value;
                
                if (!localTime) {
                    alert('Please enter a time');
                    return;
                }
                
                if (!validateTime(localTime)) {
                    return;
                }
                
                // Convert the local time to UTC for storage
                const utcTime = convertLocalToUTC(localTime);
                eventData.time = utcTime;
                
                // Send to server
                socket.emit('addEvent', eventData);
            } else {
                // NEW: Threshold-based logic
                const sensorAddress = document.getElementById('sensorAddress').value;
                const thresholdOperator = document.getElementById('thresholdOperator').value;
                const thresholdValue = document.getElementById('thresholdValue').value;
                const cooldownMinutes = document.getElementById('cooldownMinutes').value;
                
                if (!thresholdValue) {
                    alert('Please enter a threshold value');
                    return;
                }
                
                if (isNaN(parseFloat(thresholdValue))) {
                    alert('Threshold value must be a number');
                    return;
                }
                
                // Map frontend operator names to backend names
                const operatorMap = {
                    'above': 'greater_than',
                    'below': 'less_than',
                    'equals': 'equals'
                };
                
                eventData.trigger_type = triggerType;
                eventData.sensor_address = sensorAddress;
                eventData.sensor_type = triggerType; // 'temperature' or 'humidity'
                eventData.threshold_condition = operatorMap[thresholdOperator] || thresholdOperator;
                eventData.threshold_value = parseFloat(thresholdValue);
                eventData.cooldown_minutes = parseInt(cooldownMinutes) || 5;
                eventData.time = ''; // Empty time for threshold events
                
                console.log('Sending threshold event to server:', eventData);
                
                // Send to server
                socket.emit('addEvent', eventData);
                
                // Clear form
                document.getElementById('thresholdValue').value = '';
                document.getElementById('cooldownMinutes').value = '5';
            }
        }
        
        function updateEventDisplay(events) {
            currentEvents = events || []; // Store for real-time updates
            const eventList = document.getElementById('eventList');
            eventList.innerHTML = '';
            
            if (!events || events.length === 0) {
                eventList.innerHTML = '<div class="no-events">No events configured</div>';
                return;
            }
            
            // Sort events: threshold events first (by priority), then time events (chronologically)
            const sortedEvents = [...events].sort((a, b) => {
                const aIsTime = a.trigger_type === 'time' || !a.trigger_type;
                const bIsTime = b.trigger_type === 'time' || !b.trigger_type;
                
                // If both are threshold events, sort by priority (lower number = higher priority)
                if (!aIsTime && !bIsTime) {
                    const aPriority = a.priority || 1;
                    const bPriority = b.priority || 1;
                    if (aPriority !== bPriority) {
                        return aPriority - bPriority;
                    }
                    // If same priority, sort by GPIO
                    return a.gpio - b.gpio;
                }
                
                // If both are time events, sort chronologically
                if (aIsTime && bIsTime) {
                    // Convert times to local timezone for proper sorting
                    const aLocalTime = convertUTCToLocal(a.time);
                    const bLocalTime = convertUTCToLocal(b.time);
                    return aLocalTime.localeCompare(bLocalTime);
                }
                
                // Threshold events come first, then time events
                return aIsTime ? 1 : -1;
            });
            
            // Get current time in local timezone for proper comparison
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: currentTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const currentLocalTime = formatter.format(now);
            const [currentHours, currentMinutes, currentSeconds] = currentLocalTime.split(':').map(Number);
            const currentTimeSeconds = currentHours * 3600 + currentMinutes * 60 + currentSeconds;
            
            // Process time-based events for active detection
            const timeEvents = sortedEvents.filter(e => e.trigger_type === 'time' || !e.trigger_type);
            const eventsWithLocalTime = timeEvents.map(event => {
                const localTimeStr = convertUTCToLocal(event.time);
                const [localHours, localMinutes, localSeconds] = localTimeStr.split(':').map(Number);
                const localTimeSeconds = localHours * 3600 + localMinutes * 60 + localSeconds;
                
                return { ...event, localTimeStr, localTimeSeconds };
            });
            
            // Find active time-based events (the most recent past event or next future event for each GPIO)
            const activeTimeEvents = {};
            eventsWithLocalTime.forEach(event => {
                if (!event.enabled) return;
                
                const gpio = event.gpio;
                const eventTime = event.localTimeSeconds;
                
                // If no active event for this GPIO yet, or this event is a better candidate
                if (!activeTimeEvents[gpio]) {
                    activeTimeEvents[gpio] = { time: eventTime, event: event };
                } else {
                    const currentActive = activeTimeEvents[gpio];
                    
                    // If current time is past both events, choose the most recent one
                    if (eventTime <= currentTimeSeconds && currentActive.time <= currentTimeSeconds) {
                        if (eventTime > currentActive.time) {
                            activeTimeEvents[gpio] = { time: eventTime, event: event };
                        }
                    }
                    // If current time is before both events, choose the earliest one
                    else if (eventTime > currentTimeSeconds && currentActive.time > currentTimeSeconds) {
                        if (eventTime < currentActive.time) {
                            activeTimeEvents[gpio] = { time: eventTime, event: event };
                        }
                    }
                    // If one is past and one is future, choose the past one (it's currently active)
                    else if (eventTime <= currentTimeSeconds && currentActive.time > currentTimeSeconds) {
                        activeTimeEvents[gpio] = { time: eventTime, event: event };
                    }
                    // If current active is past and this one is future, keep the current active
                }
            });
            
            // Group events by GPIO to determine which should show "Live"
            const eventsByGpio = {};
            sortedEvents.forEach(event => {
                if (!eventsByGpio[event.gpio]) {
                    eventsByGpio[event.gpio] = [];
                }
                eventsByGpio[event.gpio].push(event);
            });
            
            // Determine the active event for each GPIO (highest priority)
            const activeEventsByGpio = {};
            Object.keys(eventsByGpio).forEach(gpio => {
                const gpioEvents = eventsByGpio[gpio].filter(e => e.enabled); // Only consider enabled events
                let activeEvent = null;
                
                gpioEvents.forEach(event => {
                    let isEventActive = false;
                    
                    if (event.trigger_type === 'time' || !event.trigger_type) {
                        // Time-based event logic - show Live on the controlling event
                        // This is either the most recent past event OR the next upcoming event if no past events
                        isEventActive = activeTimeEvents[event.gpio] && 
                                       activeTimeEvents[event.gpio].event.id === event.id;
                    } else {
                        // Threshold-based event logic - show Live for very brief period (0.5 seconds)
                        // This matches the backend active window for immediate safety response
                        if (event.last_triggered_at) {
                            const lastTriggered = new Date(event.last_triggered_at);
                            const timeSinceTriggered = Date.now() - lastTriggered.getTime();
                            isEventActive = timeSinceTriggered < 500; // 0.5 seconds
                        } else {
                            isEventActive = false;
                        }
                    }
                    
                    // If this event is active, check if it has higher priority than current active
                    if (isEventActive) {
                        const currentPriority = event.priority || 1;
                        const activePriority = activeEvent ? (activeEvent.priority || 1) : 999;
                        
                        if (!activeEvent || currentPriority < activePriority) {
                            activeEvent = event;
                        }
                    }
                });
                
                if (activeEvent) {
                    activeEventsByGpio[gpio] = activeEvent.id;
                }
            });

            sortedEvents.forEach((event, index) => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'event-item';
                eventDiv.setAttribute('data-index', event.id);
                
                let triggerInfo = '';
                let statusInfo = '';
                
                if (event.trigger_type === 'time' || !event.trigger_type) {
                    // Time-based event
                    const localTimeStr = convertUTCToLocal(event.time);
                    triggerInfo = `<span class="event-time">${localTimeStr}</span>`;
                    statusInfo = `<span class="countdown" id="countdown-${event.id}">--:--:--</span>`;
                } else {
                    // Threshold-based event
                    const condition = event.threshold_condition === 'greater_than' ? 'above' : 
                                     event.threshold_condition === 'less_than' ? 'below' : 
                                     event.threshold_condition;
                    const unit = event.sensor_type === 'temperature' ? '°F' : '%';
                    
                    triggerInfo = `
                        <span class="event-sensor">${event.sensor_address}</span>
                        <span class="event-threshold">${condition} ${event.threshold_value}${unit}</span>
                    `;
                    
                    // Show trigger button with cooldown timer
                    let timeDisplay;
                    let buttonClass;
                    let buttonAction;
                    
                    if (event.cooldown_active === 1 && event.cooldown_started_at) {
                        // Event is in cooldown - show remaining time and make orange
                        const cooldownStarted = new Date(event.cooldown_started_at);
                        const cooldownMs = (event.cooldown_minutes || 5) * 60 * 1000;
                        const timeLeft = cooldownMs - (Date.now() - cooldownStarted.getTime());
                        
                        if (timeLeft > 0) {
                            const minutesLeft = Math.floor(timeLeft / 60000);
                            const secondsLeft = Math.ceil((timeLeft % 60000) / 1000);
                            if (minutesLeft > 0) {
                                timeDisplay = `${minutesLeft}m ${secondsLeft}s`;
                            } else {
                                timeDisplay = `${secondsLeft}s`;
                            }
                            buttonClass = 'trigger-button-cooldown';
                            buttonAction = `resetCooldown(${event.id})`;
                        } else {
                            // Cooldown should have expired - show as ready
                            const totalMinutes = event.cooldown_minutes || 5;
                            if (totalMinutes >= 60) {
                                const hours = Math.floor(totalMinutes / 60);
                                const minutes = totalMinutes % 60;
                                timeDisplay = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                            } else {
                                timeDisplay = `${totalMinutes}m`;
                            }
                            buttonClass = 'trigger-button-ready';
                            buttonAction = `triggerEvent(${event.id})`;
                        }
                    } else {
                        // Event is ready - show full cooldown time and make green
                        const totalMinutes = event.cooldown_minutes || 5;
                        if (totalMinutes >= 60) {
                            const hours = Math.floor(totalMinutes / 60);
                            const minutes = totalMinutes % 60;
                            timeDisplay = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                        } else {
                            timeDisplay = `${totalMinutes}m`;
                        }
                        buttonClass = 'trigger-button-ready';
                        buttonAction = `triggerEvent(${event.id})`;
                    }
                    
                    statusInfo = `<button class="${buttonClass}" 
                        data-event-id="${event.id}"
                        onclick="${buttonAction}">${timeDisplay}</button>`;
                }
                
                const percentage = Math.round((event.pwm_value / 1023) * 100);
                const triggerTypeDisplay = event.trigger_type || 'time';
                
                // Only show "Live" if this is the active event for this GPIO
                const isActive = activeEventsByGpio[event.gpio] === event.id;
                const liveIndicator = isActive ? '<span class="live-indicator">Live <span class="live-dot"></span></span>' : '';
                
                // Different layouts for time-based vs threshold-based events
                if (event.trigger_type === 'time' || !event.trigger_type) {
                    // Time-based events: swap PWM and countdown positions
                    eventDiv.innerHTML = `
                        <span class="event-gpio gpio-${event.gpio}">GPIO${event.gpio}</span>
                        <span class="event-priority">${event.priority || 1}</span>
                        <span class="event-type ${triggerTypeDisplay}">${triggerTypeDisplay}</span>
                        ${triggerInfo}
                        ${statusInfo}
                        <span class="event-pwm">${event.pwm_value}/1023 ${percentage}%</span>
                        ${liveIndicator}
                        <label class="toggle event-enabled">
                            <input type="checkbox" ${event.enabled ? 'checked' : ''} 
                                   onchange="toggleEvent(${event.id}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="delete" onclick="deleteEvent(${event.id})">Delete</button>
                    `;
                } else {
                    // Threshold-based events: keep original order
                    eventDiv.innerHTML = `
                        <span class="event-gpio gpio-${event.gpio}">GPIO${event.gpio}</span>
                        <span class="event-priority">${event.priority || 1}</span>
                        <span class="event-type ${triggerTypeDisplay}">${triggerTypeDisplay}</span>
                        ${triggerInfo}
                        <span class="event-pwm">${event.pwm_value}/1023 ${percentage}%</span>
                        ${statusInfo}
                        ${liveIndicator}
                        <label class="toggle event-enabled">
                            <input type="checkbox" ${event.enabled ? 'checked' : ''} 
                                   onchange="toggleEvent(${event.id}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="delete" onclick="deleteEvent(${event.id})">Delete</button>
                    `;
                }
                
                eventList.appendChild(eventDiv);
                
                // Update countdown for time-based events
                if (event.trigger_type === 'time' || !event.trigger_type) {
                    const localTimeStr = convertUTCToLocal(event.time);
                    updateCountdown(event.id, localTimeStr);
                }
            });
        }

        // Custom confirmation dialog
        function showConfirmDialog(message, onConfirm, onCancel) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #333;
                color: #e8e6e3;
                padding: 2rem;
                border-radius: 0.5rem;
                border: 1px solid #736b5e;
                max-width: 400px;
                text-align: center;
                font-family: Arial, sans-serif;
            `;
            
            dialog.innerHTML = `
                <p style="margin-bottom: 1.5rem; font-size: 1.1rem;">${message}</p>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button id="confirmYes" style="
                        padding: 0.5rem 1rem;
                        background-color: #c0110b;
                        color: white;
                        border: none;
                        border-radius: 0.25rem;
                        cursor: pointer;
                        font-size: 1rem;
                    ">Delete</button>
                    <button id="confirmNo" style="
                        padding: 0.5rem 1rem;
                        background-color: #4f5559;
                        color: white;
                        border: none;
                        border-radius: 0.25rem;
                        cursor: pointer;
                        font-size: 1rem;
                    ">Cancel</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Add event listeners
            document.getElementById('confirmYes').onclick = () => {
                document.body.removeChild(overlay);
                onConfirm();
            };
            
            document.getElementById('confirmNo').onclick = () => {
                document.body.removeChild(overlay);
                onCancel();
            };
            
            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    onCancel();
                }
            };
        }

        function deleteEvent(id) {
            console.log('deleteEvent called with id:', id); // Debug log
            console.log('Event element:', document.querySelector(`[data-index="${id}"]`)); // Debug log
            
            showConfirmDialog(
                'Are you sure you want to delete this event?',
                () => {
                    console.log('User confirmed deletion, emitting deleteEvent to server'); // Debug log
                    socket.emit('deleteEvent', { id });
                },
                () => {
                    console.log('User cancelled deletion'); // Debug log
                }
            );
        }

        function toggleEvent(id, enabled) {
            socket.emit('toggleEvent', { id, enabled });
        }

        function updateUI(data) {
            if (data.events) {
                updateEventDisplay(data.events);
            }
        }
        
        // ==== MANUAL PWM FUNCTIONALITY ====
        
        // Handle PWM state updates
        socket.on('pwmStateUpdate', (data) => {
            console.log('Received PWM state update:', data);
            updatePWMDisplay(data);
        });
        
        // Handle initial state data (includes PWM states)
        socket.on('initialState', (data) => {
            console.log('Received initial state:', data);
            if (data.pwmStates) {
                updatePWMDisplay(data.pwmStates);
            }
            // Update mode toggle if present
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle && data.mode !== undefined) {
                modeToggle.checked = data.mode === 0; // 0 is automatic
            }
        });
        
        // PWM control functions
        function setPWM(pin) {
            const input = document.getElementById(`pwm-${pin}`);
            const value = parseInt(input.value);
            
            console.log('Setting PWM value:', { pin, value });
            
            // Send to server
            socket.emit('pwmSet', { pin: pin, value: value });
        }

        function togglePWM(pin, enabled) {
            console.log('Toggling PWM:', { pin, enabled });
            socket.emit('pwmToggle', { pin, enabled });
        }

        socket.on('pwmError', (data) => {
            console.log('Received pwmError:', data);
            const { pin, message, blocked } = data;
            alert(`PWM Error (GPIO${pin}): ${message}`);
        });
        
        // Custom initialization for this page
        function customInit() {
            // Initial clock update
            updateClock();
            setInterval(updateClock, 1000);
            
            // Request timezone
            socket.emit('getTimezone');
            
            // Request events from server
            socket.emit('getEvents');
            
            // Initialize PWM display immediately to ensure it's always visible
            updatePWMDisplay({});
            
            // Request initial state (includes PWM data)
            socket.emit('getInitialState');
            
            // Set up listener for mode toggle
            const modeToggle = document.getElementById('modeToggle');
            if (modeToggle) {
                modeToggle.addEventListener('change', function() {
                    socket.emit('setMode', { automatic: this.checked });
                });
            }
            
            // Set up GPIO button selection
            setupGpioButtons();
            
            // Initialize form to default state (Time trigger)
            initializeEventForm();
        }
        
        // NEW: Initialize event form to default state
        function initializeEventForm() {
            // Set trigger type to "time" (first option)
            const triggerType = document.getElementById('triggerType');
            if (triggerType) {
                triggerType.value = 'time';
                // Call updateEventForm to show/hide appropriate fields
                updateEventForm();
            }
            
            // Initialize PWM percentage display
            updatePWMPercentage();
        }
        
        // NEW: GPIO button selection functionality
        function setupGpioButtons() {
            const gpioButtons = document.querySelectorAll('.gpio-btn');
            
            gpioButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove selected class from all buttons
                    gpioButtons.forEach(btn => btn.classList.remove('selected'));
                    
                    // Add selected class to clicked button
                    this.classList.add('selected');
                });
            });
            
            // Ensure GPIO 12 is selected by default (it should already have the 'selected' class in HTML)
            const gpio12Button = document.querySelector('.gpio-btn-12');
            if (gpio12Button && !gpio12Button.classList.contains('selected')) {
                gpioButtons.forEach(btn => btn.classList.remove('selected'));
                gpio12Button.classList.add('selected');
            }
        }
        
        // Initialize the application
        initializeApp(socket, customInit);

        function updatePWMDisplay(pwmStates) {
            const pwmContainer = document.getElementById('pwmContainer');
            
            // Always ensure the container exists and is visible
            if (!pwmContainer) {
                console.error('PWM container not found!');
                return;
            }
            
            // Clear existing content
            pwmContainer.innerHTML = '';
            
            // Check if we have actual data - be more flexible about data format
            const hasData = pwmStates && (
                (pwmStates.current && Object.keys(pwmStates.current).length > 0) || 
                (pwmStates.manual && Object.keys(pwmStates.manual).length > 0)
            );
            
            console.log('PWM Display Update:', { pwmStates, hasData }); // Debug log
            
            // Always show all 4 GPIO controls
            [12, 13, 18, 19].forEach(gpio => {
                const pwmDiv = document.createElement('div');
                pwmDiv.className = 'pwm-control';
                pwmDiv.dataset.gpio = gpio;
                
                if (hasData) {
                    // Use real data when available
                    const currentStates = pwmStates.current || {};
                    const manualStates = pwmStates.manual || {};
                    
                    const currentState = currentStates[gpio] || { value: 0, enabled: false };
                    const manualState = manualStates[gpio] || { value: 0, enabled: false };
                    
                    const percentage = Math.round((currentState.value / 1023) * 100);
                    
                    pwmDiv.innerHTML = `
                        <span class="gpio-title gpio-title-${gpio}">GPIO${gpio}</span>
                        <input type="number" class="pwm-input" id="pwm-${gpio}" value="${manualState.value}" min="0" max="1023" step="1">
                        <span class="event-pwm">${currentState.value}/1023 ${percentage}%</span>
                        <label class="switch pwm-toggle">
                            <input type="checkbox" ${manualState.enabled ? 'checked' : ''} 
                                   onchange="togglePWM(${gpio}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="pwm-set" onclick="setPWM(${gpio})">Set</button>
                    `;
                } else {
                    // Show loading placeholders when no data
                    pwmDiv.innerHTML = `
                        <span class="gpio-title gpio-title-${gpio}">GPIO${gpio}</span>
                        <input type="number" class="pwm-input" id="pwm-${gpio}" value="" placeholder="..." min="0" max="1023" step="1" disabled>
                        <span class="event-pwm">Loading...</span>
                        <label class="switch pwm-toggle">
                            <input type="checkbox" disabled>
                            <span class="slider"></span>
                        </label>
                        <button class="pwm-set" onclick="setPWM(${gpio})" disabled>Set</button>
                    `;
                }
                
                pwmContainer.appendChild(pwmDiv);
            });
        }

        function updatePWMPercentage() {
            const pwmValue = document.getElementById('pwmValue').value;
            const pwmPercentage = document.getElementById('pwmPercentage');
            
            if (pwmValue) {
                const percentage = Math.round((Number(pwmValue) / 1023) * 100);
                pwmPercentage.textContent = `${percentage}%`;
            } else {
                pwmPercentage.textContent = '0%';
            }
        }

        function triggerEvent(id) {
            console.log('Manual trigger requested for event:', id);
            
            // Send trigger request - database will handle cooldown state
            socket.emit('triggerEvent', { id, triggerTime: new Date().toISOString() });
        }

        function resetCooldown(id) {
            console.log('Reset cooldown requested for event:', id);
            
            // Send reset request - database will handle cooldown state
            socket.emit('resetCooldown', { id });
        }

        // Real-time updates for countdowns and cooldowns
        setInterval(() => {
            // Update countdowns for time-based events
            document.querySelectorAll('.countdown').forEach(element => {
                const eventId = element.id.replace('countdown-', '');
                const event = currentEvents.find(e => e.id == eventId);
                if (event && (event.trigger_type === 'time' || !event.trigger_type)) {
                    const localTimeStr = convertUTCToLocal(event.time);
                    updateCountdown(eventId, localTimeStr);
                }
            });
            
            // Update cooldown buttons for threshold events using database state
            document.querySelectorAll('.trigger-button-cooldown, .trigger-button-ready').forEach(button => {
                const eventId = button.getAttribute('data-event-id');
                if (!eventId) return;
                
                const event = currentEvents.find(e => e.id == eventId);
                if (!event) return;
                
                let timeDisplay;
                let buttonClass;
                let buttonAction;
                
                if (event.cooldown_active === 1 && event.cooldown_started_at) {
                    // Event is in cooldown - show remaining time
                    const cooldownStarted = new Date(event.cooldown_started_at);
                    const cooldownMs = (event.cooldown_minutes || 5) * 60 * 1000;
                    const timeLeft = cooldownMs - (Date.now() - cooldownStarted.getTime());
                    
                    if (timeLeft > 0) {
                        const minutesLeft = Math.floor(timeLeft / 60000);
                        const secondsLeft = Math.ceil((timeLeft % 60000) / 1000);
                        if (minutesLeft > 0) {
                            timeDisplay = `${minutesLeft}m ${secondsLeft}s`;
                        } else {
                            timeDisplay = `${secondsLeft}s`;
                        }
                        buttonClass = 'trigger-button-cooldown';
                        buttonAction = () => resetCooldown(eventId);
                    } else {
                        // Cooldown should have expired - show as ready
                        const totalMinutes = event.cooldown_minutes || 5;
                        if (totalMinutes >= 60) {
                            const hours = Math.floor(totalMinutes / 60);
                            const minutes = totalMinutes % 60;
                            timeDisplay = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                        } else {
                            timeDisplay = `${totalMinutes}m`;
                        }
                        buttonClass = 'trigger-button-ready';
                        buttonAction = () => triggerEvent(eventId);
                    }
                } else {
                    // Event is ready - show full cooldown time
                    const totalMinutes = event.cooldown_minutes || 5;
                    if (totalMinutes >= 60) {
                        const hours = Math.floor(totalMinutes / 60);
                        const minutes = totalMinutes % 60;
                        timeDisplay = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                    } else {
                        timeDisplay = `${totalMinutes}m`;
                    }
                    buttonClass = 'trigger-button-ready';
                    buttonAction = () => triggerEvent(eventId);
                }
                
                // Only update if state has changed
                if (button.className !== buttonClass || button.textContent !== timeDisplay) {
                    button.textContent = timeDisplay;
                    button.className = buttonClass;
                    button.onclick = buttonAction;
                }
            });
        }, 1000); // Update every second
    </script>
</body>
</html> 